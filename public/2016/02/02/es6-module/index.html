<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ES6-Module - 寻梦的尕柳</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="ES6的Class只是面向对象编程的语法糖，升级了ES5的构造函数的原型链继承的写法，并没有解决模块化问题。Module功能就是为了解决这个问题而提出的。在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6-Module">
<meta property="og:url" content="http://www.haiyue.me/2016/02/02/es6-module/index.html">
<meta property="og:site_name" content="寻梦的尕柳">
<meta property="og:description" content="ES6的Class只是面向对象编程的语法糖，升级了ES5的构造函数的原型链继承的写法，并没有解决模块化问题。Module功能就是为了解决这个问题而提出的。在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES6-Module">
<meta name="twitter:description" content="ES6的Class只是面向对象编程的语法糖，升级了ES5的构造函数的原型链继承的写法，并没有解决模块化问题。Module功能就是为了解决这个问题而提出的。在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>

<body>
  <div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo logo-text" href="/">寻梦的尕柳</a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/categories/编程">编程</a>
        
          <a class="main-nav-link" href="/categories/笔记">笔记</a>
        
          <a class="main-nav-link" href="/categories/摄影">摄影</a>
        
          <a class="main-nav-link" href="/tags">标签</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于我</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="q" value="site:http://www.haiyue.me"></form>
        </div>
      </nav>
    </div>
  </div>
</header>
    <section id="main" class="outer"><article id="post-es6-module" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      ES6-Module
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/02/02/es6-module/" class="article-date">
  <time datetime="2016-02-01T16:00:00.000Z" itemprop="datePublished">2016-02-02</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/笔记/">笔记</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>ES6的Class只是面向对象编程的语法糖，升级了ES5的构造函数的原型链继承的写法，并没有解决模块化问题。Module功能就是为了解决这个问题而提出的。<br>在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。</p>
<pre><code>// CommonJS模块
<span class="built_in">let</span> { <span class="built_in">stat</span>, exists, <span class="built_in">read</span>File } = require(<span class="string">'fs'</span>);
</code></pre><p>上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取3个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p>
<a id="more"></a> 
<pre><code><span class="comment">// ES6模块</span>
<span class="keyword">import</span> { stat, exists, readFile } <span class="keyword">from</span> <span class="string">'fs'</span>;
</code></pre><p>上面代码的实质是从fs模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”，即ES6可以在编译时就完成模块加载，效率要比CommonJS模块的加载方式高。当然，这也导致了没法引用ES6模块本身，因为它不是对象。</p>
<h2 id="严格模式(ES5引入)">严格模式(ES5引入)</h2><p>ES6的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”。</p>
<h2 id="export命令">export命令</h2><p>模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。<br>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。</p>
<pre><code><span class="comment">// good</span>
<span class="literal">export</span> <span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;
<span class="literal">export</span> <span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;
<span class="comment">// best</span>
<span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;
<span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;
<span class="literal">export</span> {firstName, lastName};
</code></pre><p>export命令除了输出变量，还可以输出函数或类（class）。</p>
<pre><code><span class="keyword">function</span> v1() { <span class="keyword">...</span> }
<span class="keyword">function</span> v2() { <span class="keyword">...</span> }
export {
  v1 as streamV1,
  v2 as streamV2,
  v2 as streamLatestVersion
};
</code></pre><p>export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下面的import命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。<br>export语句输出的值是动态绑定，绑定其所在的模块。</p>
<pre><code><span class="reserved">export</span> <span class="reserved">var</span> foo = <span class="string">'bar'</span>;
setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> foo = <span class="string">'baz'</span>, <span class="number">500</span>);
</code></pre><p>上面代码输出变量foo，值为bar，500毫秒之后变成baz。</p>
<h2 id="import命令">import命令</h2><p>使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）。</p>
<pre><code><span class="keyword">import</span> {firstName, lastName, year} <span class="keyword">from</span> <span class="string">'./profile'</span>;
</code></pre><p>import命令接受一个对象（用大括号表示），里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。<br>如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。</p>
<pre><code><span class="keyword">import</span> { lastName <span class="keyword">as</span> surname } <span class="keyword">from</span> <span class="string">'./profile'</span>;
</code></pre><p>import命令具有提升效果，会提升到整个模块的头部，首先执行。</p>
<pre><code>foo();
<span class="keyword">import</span> { foo } <span class="keyword">from</span> <span class="string">'my_module'</span>;
</code></pre><p>如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。</p>
<pre><code><span class="literal">export</span> { es6 <span class="literal">as</span> <span class="keyword">default</span> } from <span class="string">'./someModule'</span>;
<span class="comment">// 等同于 (best)</span>
<span class="literal">import</span> { es6 } from <span class="string">'./someModule'</span>;
<span class="literal">export</span> <span class="keyword">default</span> es6;
</code></pre><h2 id="模块的整体加载">模块的整体加载</h2><p>除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。</p>
<pre><code><span class="keyword">import</span> * as circle <span class="keyword">from</span> <span class="string">'./circle'</span>;
<span class="built_in">console</span>.log(<span class="string">"圆面积："</span> <span class="string">\+</span> circle.area(<span class="number">4</span>));
<span class="built_in">console</span>.log(<span class="string">"圆周长："</span> <span class="string">\+</span> circle.circumference(<span class="number">14</span>));
</code></pre><h3 id="export_default命令">export default命令</h3><p>export default命令，为模块指定默认输出。一个模块只能有一个默认输出，因此export deault命令只能使用一次。</p>
<pre><code>export <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);
}
</code></pre><p>其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。这时import命令后面，不使用大括号。</p>
<pre><code><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">'./export-default'</span>;
customName(); <span class="comment">// 'foo'</span>
</code></pre><p>export default命令用在非匿名函数前，也是可以的。加载的时候，视同匿名函数加载。<br>如果想在一条import语句中，同时输入默认方法和其他变量，可以写成下面这样。  </p>
<pre><code><span class="keyword">import</span> customName, { otherMethod } <span class="keyword">from</span> <span class="string">'./export-default'</span>;
</code></pre><h2 id="模块的继承">模块的继承</h2><pre><code><span class="keyword">export</span> * from <span class="string">'circle'</span>;
<span class="keyword">export</span> <span class="keyword">var</span> e = <span class="number">2.71828182846</span>;
<span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span><span class="params">(x)</span> </span>{
  <span class="keyword">return</span> <span class="built_in">Math</span>.exp(x);
}
</code></pre><p>上面代码中的export <em>，表示再输出circle模块的所有属性和方法。注意，export </em>命令会忽略circle模块的default方法。然后，上面代码又输出了自定义的e变量和默认方法。</p>
<h2 id="ES6模块加载的实质">ES6模块加载的实质</h2><p>ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，一旦输出一个值，模块内部的变化就影响不到这个值。而ES6模块输出的是值的引,用此，ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。。<br>由于ES6输入的模块变量，只是一个”符号连接“，所以这个变量是只读的，对它进行重新赋值会报错。</p>
<h2 id="ES6模块的循环加载">ES6模块的循环加载</h2><p>ES6处理“循环加载”与CommonJS有本质的不同。ES6模块是动态引用，遇到模块加载命令import时，不会去执行模块，只是生成一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</p>
<h2 id="ES6模块的转码">ES6模块的转码</h2><p>浏览器目前还不支持ES6模块，为了现在就能使用，可以将转为ES5的写法。除了Babel可以用来转码之外，还有以下两个方法，也可以用来转码。</p>
<pre><code><span class="constant">ES6</span> <span class="class"><span class="keyword">module</span> <span class="title">transpiler</span></span>
<span class="constant">SystemJS</span>
</code></pre><p>读阮一峰老师《ECMAScript6入门》一书的笔记<br><br></p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ECMAScript6入门/">ECMAScript6入门</a></li></ul>

      </footer>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/02/02/es6-class/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-title"><span>&lt;</span>&nbsp;
        
          ES6-Class基本语法
        
      </div>
    </a>
  
  
    <a href="/2016/01/06/photo/lansegangwan/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">蓝色港湾跨年夜&nbsp;<span>&gt;</span></div>
    </a>
  
</nav>

  
</article>


  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-es6-module" data-title="ES6-Module" data-url="http://www.haiyue.me/2016/02/02/es6-module/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'liuhaiming'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>
  </section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 寻梦的尕柳&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    

<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>
  </div>
</body>
</html>