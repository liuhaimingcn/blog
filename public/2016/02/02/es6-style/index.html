<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ES6-Module - 寻梦的尕柳</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="规格文件规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。ECMAScript 6的规格，可以在ECMA国际标准组织的官方网站（www.ecma-international.org/ecma-262/6.0/）免费下载和在线阅读。">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6-Module">
<meta property="og:url" content="http://www.haiyue.me/2016/02/02/es6-style/index.html">
<meta property="og:site_name" content="寻梦的尕柳">
<meta property="og:description" content="规格文件规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。ECMAScript 6的规格，可以在ECMA国际标准组织的官方网站（www.ecma-international.org/ecma-262/6.0/）免费下载和在线阅读。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES6-Module">
<meta name="twitter:description" content="规格文件规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。ECMAScript 6的规格，可以在ECMA国际标准组织的官方网站（www.ecma-international.org/ecma-262/6.0/）免费下载和在线阅读。">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>

<body>
  <div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo logo-text" href="/">寻梦的尕柳</a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/categories/编程">编程</a>
        
          <a class="main-nav-link" href="/categories/笔记">笔记</a>
        
          <a class="main-nav-link" href="/categories/摄影">摄影</a>
        
          <a class="main-nav-link" href="/tags">标签</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于我</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="q" value="site:http://www.haiyue.me"></form>
        </div>
      </nav>
    </div>
  </div>
</header>
    <section id="main" class="outer"><article id="post-es6-style" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      ES6-Module
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/02/02/es6-style/" class="article-date">
  <time datetime="2016-02-01T16:00:00.000Z" itemprop="datePublished">2016-02-02</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/笔记/">笔记</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="规格文件">规格文件</h1><p>规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。<br>ECMAScript 6的规格，可以在ECMA国际标准组织的官方网站（www.ecma-international.org/ecma-262/6.0/）免费下载和在线阅读。</p>
<a id="more"></a> 
<h1 id="编程风格">编程风格</h1><h2 id="块级作用域">块级作用域</h2><p>let取代var<br>全局常量和线程安全<br>在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。这符合函数式编程思想，有利于将来的分布式运算。</p>
<pre><code><span class="comment">// bad</span>
<span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;
<span class="comment">// good</span>
<span class="keyword">const</span> a = <span class="number">1</span>;
<span class="keyword">const</span> b = <span class="number">2</span>;
<span class="keyword">const</span> c = <span class="number">3</span>;
</code></pre><p>const声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。<br>所有的函数都应该设置为常量。</p>
<h2 id="严格模式">严格模式</h2><p>V8引擎只在严格模式之下，支持let。  </p>
<h2 id="字符串">字符串</h2><p>静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。</p>
<pre><code><span class="comment">// bad</span>
<span class="keyword">const</span> a = <span class="string">"foobar"</span>;
<span class="keyword">const</span> b = <span class="string">'foo'</span> + a + <span class="string">'bar'</span>;
<span class="comment">// good</span>
<span class="keyword">const</span> a = <span class="string">'foobar'</span>;
<span class="keyword">const</span> b = <span class="string">`foo${a}bar`</span>;
</code></pre><h2 id="解构赋值">解构赋值</h2><p>使用数组成员对变量赋值时，优先使用解构赋值。</p>
<pre><code><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];
<span class="comment">// bad</span>
<span class="keyword">const</span> first = arr[<span class="number">0</span>];
<span class="keyword">const</span> <span class="built_in">second</span> = arr[<span class="number">1</span>];
<span class="comment">// good</span>
<span class="keyword">const</span> [first, <span class="built_in">second</span>] = arr;
</code></pre><p>函数的参数如果是对象的成员，优先使用解构赋值。</p>
<pre><code><span class="comment">// bad</span>
<span class="function"><span class="keyword">function</span> <span class="title">getFullName</span><span class="params">(user)</span> </span>{
  <span class="keyword">const</span> firstName = user.firstName;
  <span class="keyword">const</span> lastName = user.lastName;
}
<span class="comment">// best</span>
<span class="function"><span class="keyword">function</span> <span class="title">getFullName</span><span class="params">({ firstName, lastName })</span> </span>{
}
</code></pre><p>如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。</p>
<pre><code><span class="comment">// bad</span>
<span class="function"><span class="keyword">function</span> <span class="title">processInput</span><span class="params">(input)</span> </span>{
  <span class="keyword">return</span> [left, right, top, bottom];
}
<span class="comment">// good</span>
<span class="function"><span class="keyword">function</span> <span class="title">processInput</span><span class="params">(input)</span> </span>{
  <span class="keyword">return</span> { left, right, top, bottom };
}
<span class="keyword">const</span> { left, right } = processInput(input);
</code></pre><h2 id="数组">数组</h2><p>使用扩展运算符（…）拷贝数组。</p>
<pre><code><span class="comment">// bad</span>
<span class="keyword">const</span> <span class="built_in">len</span> = items.length;
<span class="keyword">const</span> itemsCopy = [];
<span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>; i++) {
  itemsCopy[i] = items[i];
}
<span class="comment">// good</span>
<span class="keyword">const</span> itemsCopy = [...items];
</code></pre><p>使用Array.from方法，将类似数组的对象转为数组。</p>
<pre><code><span class="keyword">const</span> foo = <span class="built_in">document</span>.<span class="built_in">querySelectorAll</span>(<span class="string">'.foo'</span>);
<span class="keyword">const</span> nodes = Array.from(foo);
</code></pre><p>立即执行函数可以写成箭头函数的形式。</p>
<pre><code><span class="list">(<span class="list">()</span> =&gt; <span class="collection">{
  console.log<span class="list">(<span class="keyword">'Welcome</span> to the Internet.')</span><span class="comment">;</span>
}</span>)</span><span class="list">()</span><span class="comment">;</span>
</code></pre><p>那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了this。</p>
<pre><code><span class="comment">// bad</span>
[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> <span class="params">(x)</span> </span>{
  <span class="keyword">return</span> x * x;
});
<span class="comment">// best</span>
[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(x =&gt; x * x);
</code></pre><p>简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。  </p>
<p>不要在函数体内使用arguments变量，使用rest运算符（…）代替。因为rest运算符显式表明你想要获取参数，而且arguments是一个类似数组的对象，而rest运算符可以提供一个真正的数组。</p>
<pre><code><span class="comment">// bad</span>
<span class="function"><span class="keyword">function</span> <span class="title">concatenateAll</span><span class="params">()</span> </span>{
  <span class="keyword">const</span> args = Array.prototype.slice.call(arguments);
  <span class="keyword">return</span> args.join(<span class="string">''</span>);
}
<span class="comment">// good</span>
<span class="function"><span class="keyword">function</span> <span class="title">concatenateAll</span><span class="params">(<span class="rest_arg">...args</span>)</span> </span>{
  <span class="keyword">return</span> args.join(<span class="string">''</span>);
}
</code></pre><p>使用默认值语法设置函数参数的默认值。</p>
<pre><code>// bad
<span class="keyword">function</span> handleThings(opts) {
  opts = opts || {};
}
// good
<span class="keyword">function</span> handleThings(opts = {}) {
  // <span class="keyword">...</span>
}
</code></pre><p>所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。</p>
<pre><code><span class="comment">// bad</span>
<span class="function"><span class="keyword">function</span> <span class="title">divide</span><span class="params">(a, b, option = false )</span> </span>{
}
<span class="comment">// good</span>
<span class="function"><span class="keyword">function</span> <span class="title">divide</span><span class="params">(a, b, { option = false } = {})</span> </span>{
}
</code></pre><h2 id="Map结构">Map结构</h2><p>注意区分Object和Map，只有模拟实体对象时，才使用Object。如果只是需要key: value的数据结构，使用Map结构。因为Map有内建的遍历机制。</p>
<pre><code><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="type">Map</span>(arr);
<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys<span class="literal">()</span>) {
  console.log(key);
}
<span class="keyword">for</span> (<span class="keyword">let</span> <span class="keyword">value</span> <span class="keyword">of</span> map.values<span class="literal">()</span>) {
  console.log(<span class="keyword">value</span>);
}
<span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.entries<span class="literal">()</span>) {
  console.log(item[<span class="number">0</span>], item[<span class="number">1</span>]);
}
</code></pre><h2 id="Class">Class</h2><p>总是用Class，取代需要prototype的操作。因为Class的写法更简洁，更易于理解。</p>
<pre><code><span class="comment">// bad</span>
<span class="function"><span class="keyword">function</span> <span class="title">Queue</span><span class="params">(contents = [])</span> </span>{
  <span class="keyword">this</span>._queue = [...contents];
}
Queue.prototype.pop = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="keyword">const</span> value = <span class="keyword">this</span>._queue[<span class="number">0</span>];
  <span class="keyword">this</span>._queue.splice(<span class="number">0</span>, <span class="number">1</span>);
  <span class="keyword">return</span> value;
}
<span class="comment">// good</span>
<span class="keyword">class</span> Queue {
  <span class="constructor"><span class="keyword">constructor</span>(contents = []) </span>{
    <span class="keyword">this</span>._queue = [...contents];
  }
  pop() {
    <span class="keyword">const</span> value = <span class="keyword">this</span>._queue[<span class="number">0</span>];
    <span class="keyword">this</span>._queue.splice(<span class="number">0</span>, <span class="number">1</span>);
    <span class="keyword">return</span> value;
  }
}
</code></pre><p>使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。</p>
<pre><code><span class="comment">// bad</span>
const inherits = require(<span class="symbol">'inherit</span>s');
function <span class="type">PeekableQueue</span>(contents) {
  <span class="type">Queue</span>.apply(<span class="keyword">this</span>, contents);
}
inherits(<span class="type">PeekableQueue</span>, <span class="type">Queue</span>);
<span class="type">PeekableQueue</span>.prototype.peek = function() {
  <span class="keyword">return</span> <span class="keyword">this</span>._queue[<span class="number">0</span>];
}
<span class="comment">// good</span>
<span class="class"><span class="keyword">class</span> <span class="title">PeekableQueue</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Queue</span> {</span>
  peek() {
    <span class="keyword">return</span> <span class="keyword">this</span>._queue[<span class="number">0</span>];
  }
}
</code></pre><h2 id="模块">模块</h2><p>Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用import取代require。</p>
<pre><code><span class="comment">// bad</span>
<span class="keyword">const</span> moduleA = <span class="keyword">require</span>(<span class="string">'moduleA'</span>);
<span class="keyword">const</span> func1 = moduleA.func1;
<span class="keyword">const</span> func2 = moduleA.func2;
<span class="comment">// good</span>
import <span class="comment">{ func1, func2 }</span> <span class="keyword">from</span> <span class="string">'moduleA'</span>;
</code></pre><p>使用export取代module.exports。<br>如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，不要export default与普通的export同时使用。</p>
<pre><code><span class="regexp">//</span> commonJS的写法
<span class="reserved">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);
<span class="reserved">var</span> Breadcrumbs = React.createClass({
  render() {
    <span class="keyword">return</span> &lt;nav /&gt;;
  }
});
<span class="built_in">module</span>.exports = Breadcrumbs;
<span class="regexp">//</span> ES6的写法
<span class="reserved">import</span> React from <span class="string">'react'</span>;
<span class="reserved">const</span> Breadcrumbs = React.createClass({
  render() {
    <span class="keyword">return</span> &lt;nav /&gt;;
  }
});
<span class="reserved">export</span> <span class="reserved">default</span> Breadcrumbs
</code></pre><p>如果模块默认输出一个函数，函数名的首字母应该小写。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">makeStyleGuide</span><span class="params">()</span> </span>{
}
export <span class="keyword">default</span> makeStyleGuide;
</code></pre><p>如果模块默认输出一个对象，对象名的首字母应该大写。</p>
<pre><code><span class="reserved">const</span> StyleGuide = {
  <span class="attribute">es6</span>: {
  }
};
<span class="reserved">export</span> <span class="reserved">default</span> StyleGuide;
</code></pre><p>读阮一峰老师《ECMAScript6入门》一书的笔记<br><br></p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ECMAScript6入门/">ECMAScript6入门</a></li></ul>

      </footer>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/02/02/es6-module/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-title"><span>&lt;</span>&nbsp;
        
          ES6-Module
        
      </div>
    </a>
  
  
    <a href="/2016/02/02/es6-class/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">ES6-Class基本语法&nbsp;<span>&gt;</span></div>
    </a>
  
</nav>

  
</article>


  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-es6-style" data-title="ES6-Module" data-url="http://www.haiyue.me/2016/02/02/es6-style/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'liuhaiming'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>
  </section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 寻梦的尕柳&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    

<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>
  </div>
</body>
</html>