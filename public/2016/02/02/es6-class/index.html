<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ES6-Class基本语法 - 寻梦的尕柳</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Class基本语法ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。
// old
  function Point(x,y){
  this.x = x;
  this.y = y;
}
Point.prototype.toString = function () {
  return &apos;(&apos;">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6-Class基本语法">
<meta property="og:url" content="http://www.haiyue.me/2016/02/02/es6-class/index.html">
<meta property="og:site_name" content="寻梦的尕柳">
<meta property="og:description" content="Class基本语法ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。
// old
  function Point(x,y){
  this.x = x;
  this.y = y;
}
Point.prototype.toString = function () {
  return &apos;(&apos;">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES6-Class基本语法">
<meta name="twitter:description" content="Class基本语法ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。
// old
  function Point(x,y){
  this.x = x;
  this.y = y;
}
Point.prototype.toString = function () {
  return &apos;(&apos;">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>

<body>
  <div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo logo-text" href="/">寻梦的尕柳</a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/categories/编程">编程</a>
        
          <a class="main-nav-link" href="/categories/笔记">笔记</a>
        
          <a class="main-nav-link" href="/categories/摄影">摄影</a>
        
          <a class="main-nav-link" href="/tags">标签</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于我</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="q" value="site:http://www.haiyue.me"></form>
        </div>
      </nav>
    </div>
  </div>
</header>
    <section id="main" class="outer"><article id="post-es6-class" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      ES6-Class基本语法
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2016/02/02/es6-class/" class="article-date">
  <time datetime="2016-02-01T16:00:00.000Z" itemprop="datePublished">2016-02-02</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/笔记/">笔记</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Class基本语法">Class基本语法</h2><p>ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p>
<pre><code><span class="comment">// old</span>
  <span class="function"><span class="keyword">function</span> <span class="title">Point</span><span class="params">(x,y)</span></span>{
  <span class="keyword">this</span>.x = x;
  <span class="keyword">this</span>.y = y;
}
Point.prototype.toString = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;
}
<span class="comment">// new</span>
<span class="keyword">class</span> Point {
  <span class="constructor"><span class="keyword">constructor</span>(x, y) </span>{
    <span class="keyword">this</span>.x = x;
    <span class="keyword">this</span>.y = y;
  }
  toString() {
    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;
  }   
}
</code></pre><a id="more"></a> 
<p>Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个保留字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。<br>构造函数的prototype属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。<br>类的内部所有定义的方法，都是不可枚举的（enumerable）。这一点与ES5的行为不一致。</p>
<pre><code><span class="keyword">class</span> Point {
  <span class="constructor"><span class="keyword">constructor</span>(x, y) </span>{}
  toString() {}
}
<span class="built_in">Object</span>.keys(Point.prototype) <span class="comment">// []</span>
<span class="built_in">Object</span>.getOwnPropertyNames(Point.prototype) <span class="comment">// ["constructor","toString"]</span>
</code></pre><p>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。<br>constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</p>
<pre><code><span class="keyword">class</span> Foo {
  <span class="constructor"><span class="keyword">constructor</span>() </span>{
    <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);
  }
}
<span class="keyword">new</span> Foo() <span class="keyword">instanceof</span> Foo; <span class="comment">// false </span>
</code></pre><p>生成实例对象的写法，与ES5完全一样，也是使用new命令。如果忘记加上new，像函数那样调用Class，将会报错。<br>与ES5一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）<br>与ES5一样，类的所有实例共享一个原型对象。所以<strong>proto</strong>属性是相等的。<br>name属性总是返回紧跟在class关键字后面的类名。</p>
<pre><code>class <span class="keyword">Point</span> <span class="list">{}</span>
<span class="keyword">Point</span>.name // <span class="string">"Point"</span>
</code></pre><p>下面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在Class的内部代码可用，指代当前类。</p>
<pre><code><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>{
  getClassName() {
    <span class="keyword">return</span> Me.name;
  }
};
</code></pre><p>如果Class内部没用到的话，可以省略Me。<br>采用Class表达式，可以写出立即执行的Class。<br>Class不存在变量提升（hoist），这一点与ES5完全不同。</p>
<pre><code><span class="keyword">new</span> Foo(); <span class="comment">// ReferenceError</span>
<span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>{}
</code></pre><p>类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。<br>考虑到未来所有的代码，其实都是运行在模块之中，所以ES6实际上把整个语言升级到了严格模式。</p>
<h2 id="Class的继承">Class的继承</h2><p>Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Point</span> {</span>}
</code></pre><p>下面代码中，constructor方法和toString方法之中，都出现了super关键字，它指代父类的实例（即父类的this对象）。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Point</span> {</span>
  constructor(x, y, color) {
    <span class="keyword">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span>
    <span class="keyword">this</span>.color = color;
  }
  toString() {
    <span class="keyword">return</span> <span class="keyword">this</span>.color + ' ' + <span class="keyword">super</span>.toString(); <span class="comment">// 调用父类的toString()</span>
  }
}
</code></pre><p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。<br>子类实例的<strong>proto</strong>属性的<strong>proto</strong>属性，指向父类实例的<strong>proto</strong>属性。也就是说，子类的原型的原型，是父类的原型。</p>
<h2 id="原生构造函数的继承">原生构造函数的继承</h2><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。<br>ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Array</span> {</span>
  constructor(...args) {
    <span class="keyword">super</span>(...args);
  }
}
<span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="type">MyArray</span>();
arr[<span class="number">0</span>] = <span class="number">12</span>;
arr.length <span class="comment">// 1</span>
arr.length = <span class="number">0</span>;
arr[<span class="number">0</span>] <span class="comment">// undefined</span>
</code></pre><h2 id="Class的取值函数（getter）和存值函数（setter）">Class的取值函数（getter）和存值函数（setter）</h2><p>与ES5一样，在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<pre><code><span class="keyword">class</span> MyClass {
  <span class="constructor"><span class="keyword">constructor</span>() </span>{
    <span class="comment">// ...</span>
  }
  <span class="keyword">get</span> prop() {
    <span class="keyword">return</span> <span class="string">'getter'</span>;
  }
  <span class="keyword">set</span> prop(value) {
    <span class="built_in">console</span>.log(<span class="string">'setter: '</span>+value);
  }
}
<span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();
inst.prop = <span class="number">123</span>; <span class="comment">// setter: 123</span>
inst.prop <span class="comment">// 'getter'</span>
</code></pre><h2 id="Class的静态方法">Class的静态方法</h2><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> {</span>
  static classMethod() {
    <span class="keyword">return</span> <span class="string">'hello'</span>;
  }
}
Foo.classMethod() <span class="regexp">//</span> <span class="string">'hello'</span>
<span class="reserved">var</span> foo = <span class="keyword">new</span> Foo();
foo.classMethod() <span class="regexp">//</span> <span class="attribute">TypeError</span>: <span class="literal">undefined</span> <span class="keyword">is</span> <span class="keyword">not</span> a <span class="reserved">function</span>
</code></pre><p>父类的静态方法，可以被子类继承。<br>静态方法也是可以从super对象上调用的。</p>
<h2 id="Class的静态属性">Class的静态属性</h2><p>静态属性指的是Class本身的属性，即Class.propname，而不是定义在实例对象（this）上的属性。</p>
<pre><code><span class="keyword">class</span> Foo {
}
Foo.<span class="keyword">prop</span> = 1;
Foo.<span class="keyword">prop</span> <span class="comment">// 1</span>
</code></pre><p>目前，只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。</p>
<h2 id="new-target属性">new.target属性</h2><p>new是从构造函数生成实例的命令。ES6为new命令引入了一个new.target属性，（在构造函数中）返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name)</span> </span>{
  <span class="keyword">if</span> (<span class="keyword">new</span>.target !== <span class="literal">undefined</span>) {
    <span class="keyword">this</span>.name = name;
  } <span class="keyword">else</span> {
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必须使用new生成实例'</span>);
  }
}
<span class="comment">// 另一种写法</span>
<span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name)</span> </span>{
  <span class="keyword">if</span> (<span class="keyword">new</span>.target === Person) {
    <span class="keyword">this</span>.name = name;
  } <span class="keyword">else</span> {
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必须使用new生成实例'</span>);
  }
}
<span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'张三'</span>); <span class="comment">// 正确</span>
<span class="keyword">var</span> notAPerson = Person.call(person, <span class="string">'张三'</span>); <span class="comment">// 报错</span>
</code></pre><p>Class内部调用new.target，返回当前Class。<br>子类继承父类时，new.target会返回子类。</p>
<pre><code><span class="keyword">class</span> Rectangle {
  <span class="constructor"><span class="keyword">constructor</span>(length, width) </span>{
    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);
    <span class="comment">// ...</span>
  }
}
<span class="keyword">class</span> Square extends Rectangle {
  <span class="constructor"><span class="keyword">constructor</span>(length) </span>{
    <span class="keyword">super</span>(length, length);
  }
}
<span class="keyword">var</span> obj = <span class="keyword">new</span> Square(<span class="number">3</span>); <span class="comment">// 输出 false</span>
</code></pre><p>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</p>
<h2 id="类的修饰">类的修饰</h2><p>修饰器（Decorator）是一个表达式，用来修改类的行为。这是ES7的一个提案，目前Babel转码器已经支持。<br>修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。  </p>
<p>读阮一峰老师《ECMAScript6入门》一书的笔记<br><br></p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ECMAScript6入门/">ECMAScript6入门</a></li></ul>

      </footer>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/02/02/es6-style/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-title"><span>&lt;</span>&nbsp;
        
          ES6-Module
        
      </div>
    </a>
  
  
    <a href="/2016/01/06/photo/lansegangwan/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">蓝色港湾跨年夜&nbsp;<span>&gt;</span></div>
    </a>
  
</nav>

  
</article>


  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-es6-class" data-title="ES6-Class基本语法" data-url="http://www.haiyue.me/2016/02/02/es6-class/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'liuhaiming'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>
  </section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 寻梦的尕柳&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    

<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>
  </div>
</body>
</html>