<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[寻梦的尕柳]]></title>
  <subtitle><![CDATA[幽幽一缕香，飘在深深旧梦中，宛如挥手袖底风，淡淡回首，也无风雨也无晴。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.haiyue.me/"/>
  <updated>2016-10-25T06:52:51.000Z</updated>
  <id>http://www.haiyue.me/</id>
  
  <author>
    <name><![CDATA[寻梦的尕柳]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[yml 文件中使用环境变量]]></title>
    <link href="http://www.haiyue.me/2016/10/25/yml-evn/"/>
    <id>http://www.haiyue.me/2016/10/25/yml-evn/</id>
    <published>2016-10-24T16:00:00.000Z</published>
    <updated>2016-10-25T06:52:51.000Z</updated>
    <content type="html"><![CDATA[<p>Spring Boot 中可以用 spring.profiles.active 参数来指定系统环境，让系统加载不同的配置文件。<br>可以在程序启动的时候加上参数来指定需要的配置  </p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dspring<span class="class">.profiles</span><span class="class">.active</span>=<span class="string">"dev"</span> -jar user.jar</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>当然我们也可以事先设置好系统的环境变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expoer SERVER_EVN=<span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>然后在 yml 文件中用 active: ${SERVER_EVN} 来动态的获取系统已设置好的数据。这样这台 test 服务器中的再启动 Spring Boot 项目的时候就可以不用每次都去设置参数了。  </p>
<p>同时 yml 也支持 ${SERVER_EVN:dev} 这样的方式来设置默认值，此时如果环境变量中没有 SERVER_EVN ， active就会默认设置为”dev”。  </p>
<p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Spring Boot 中可以用 spring.profiles.active 参数来指定系统环境，让系统加载不同的配置文件。<br>可以在程序启动的时候加上参数来指定需要的配置  </p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dspring<span class="class">.profiles</span><span class="class">.active</span>=<span class="string">"dev"</span> -jar user.jar</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.haiyue.me/tags/Spring-Boot/"/>
    
      <category term="编程" scheme="http://www.haiyue.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Spring Boot 项目中只能有一个main方法]]></title>
    <link href="http://www.haiyue.me/2016/10/24/spring-boot-single-main/"/>
    <id>http://www.haiyue.me/2016/10/24/spring-boot-single-main/</id>
    <published>2016-10-23T16:00:00.000Z</published>
    <updated>2016-10-24T09:11:29.000Z</updated>
    <content type="html"><![CDATA[<p>对Spring Boot 项目用maven进行打包的时候报错以下错误  </p>
<p>[ERROR] Failed to execute goal org.springframework.boot:spring-boot-maven-plugin:1.4.1.RELEASE:repackage (default) on project nlp-user: Execution default of goal org.springframework.boot:spring-boot-maven-plugin:1.4.1.RELEASE:repackage failed: Unable to find a single main class from the following candidates [com.raventech.user.Application, com.raventech.user.util.Utils] -&gt; [Help 1]  </p>
<a id="more"></a>
<p>原来是因为 Spring Boot 项目中只能有一个main方法，不然 spring-boot-maven-plugin 在打包的过程中会扫描到了多个 main 方法，然后就懵逼不知道用哪个作为启动方法了。  </p>
<p>以前总喜欢在 Utils 中写个main方法来调试静态方法，看来以后用完就得随手把它给删除了。</p>
<p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>对Spring Boot 项目用maven进行打包的时候报错以下错误  </p>
<p>[ERROR] Failed to execute goal org.springframework.boot:spring-boot-maven-plugin:1.4.1.RELEASE:repackage (default) on project nlp-user: Execution default of goal org.springframework.boot:spring-boot-maven-plugin:1.4.1.RELEASE:repackage failed: Unable to find a single main class from the following candidates [com.raventech.user.Application, com.raventech.user.util.Utils] -&gt; [Help 1]  </p>]]>
    
    </summary>
    
      <category term="Spring Boot" scheme="http://www.haiyue.me/tags/Spring-Boot/"/>
    
      <category term="编程" scheme="http://www.haiyue.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Docker Hello World]]></title>
    <link href="http://www.haiyue.me/2016/10/09/docker-hello-world/"/>
    <id>http://www.haiyue.me/2016/10/09/docker-hello-world/</id>
    <published>2016-10-08T16:00:00.000Z</published>
    <updated>2016-10-09T07:52:57.000Z</updated>
    <content type="html"><![CDATA[<h2 id="查看linux版本">查看linux版本</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ lsb_release <span class="operator">-a</span></span><br><span class="line">LSB Version:    :core-<span class="number">4.1</span>-amd64:core-<span class="number">4.1</span>-noarch</span><br><span class="line">Distributor ID: CentOS</span><br><span class="line">Description:    CentOS Linux release <span class="number">7.2</span>.<span class="number">1511</span> (Core)</span><br><span class="line">Release:    <span class="number">7.2</span>.<span class="number">1511</span></span><br><span class="line">Codename:   Core</span><br></pre></td></tr></table></figure>
<a id="more"></a>   
<h2 id="Docker_环境准备">Docker 环境准备</h2><ul>
<li>CentOS7 系统 CentOS-Extras 库中已带 Docker，可以直接安装</li>
</ul>
<h3 id="安装">安装</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ su root</span><br><span class="line"><span class="comment"># yum install docker</span></span><br></pre></td></tr></table></figure>
<h3 id="启动">启动</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service docker start</span></span><br><span class="line">Redirecting to /bin/systemctl start  docker.service</span><br></pre></td></tr></table></figure>
<h3 id="让它随系统启动自动加载">让它随系统启动自动加载</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># service docker start</span></span><br><span class="line">Redirecting to /bin/systemctl start  docker.service</span><br><span class="line"><span class="comment"># chkconfig docker on</span></span><br><span class="line">注意：正在将请求转发到“systemctl <span class="built_in">enable</span> docker.service”。</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.</span><br></pre></td></tr></table></figure>
<h2 id="镜像">镜像</h2><h3 id="获取镜像">获取镜像</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker pull ubuntu:12.04</span></span><br><span class="line">Trying to pull repository docker.io/library/ubuntu ...</span><br><span class="line"><span class="number">12.04</span>: Pulling from docker.io/library/ubuntu</span><br><span class="line"><span class="number">36</span>cef014d5d4: Pull complete</span><br><span class="line"><span class="number">0</span>d99ad4de1d2: Pull complete</span><br><span class="line"><span class="number">3</span>e32dbf1ab94: Pull complete</span><br><span class="line"><span class="number">44710</span>c456ffc: Pull complete</span><br><span class="line"><span class="number">56</span>e70ac3b314: Pull complete</span><br><span class="line">Digest: sha256:<span class="number">0</span>c25aa67baaff2b895882ce1e7d25efeeb15d0f38df6c099e23f481641<span class="built_in">cd</span>6cab</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> docker.io/ubuntu:<span class="number">12.04</span></span><br></pre></td></tr></table></figure>
<h3 id="列出本地已有的镜像">列出本地已有的镜像</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">docker.io/ubuntu    <span class="number">12.04</span>               e216a057b1cb        <span class="number">12</span> days ago         <span class="number">103.6</span> MB</span><br></pre></td></tr></table></figure>
<ul>
<li>REPOSITORY: 来自于哪个仓库</li>
<li>TAG: 镜像的标记（如果不指定具体的标记，则默认使用 latest 标记信息。）</li>
<li>IMAGE ID: 它的 ID 号（唯一）</li>
<li>CREATED: 创建时间</li>
<li>SIZE: 镜像大小</li>
</ul>
<h3 id="创建镜像">创建镜像</h3><ul>
<li>修改已有镜像</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker run -t -i docker.io/ubuntu:12.04 /bin/bash</span></span><br><span class="line">root@d7ac9b2f8<span class="built_in">cd</span>7:/<span class="comment"># apt-get update</span></span><br><span class="line">root@d7ac9b2f8<span class="built_in">cd</span>7:/<span class="comment"># apt-get install nodejs</span></span><br><span class="line">root@d7ac9b2f8<span class="built_in">cd</span>7:/<span class="comment"># node -v</span></span><br><span class="line">v0.<span class="number">6.12</span></span><br><span class="line">root@d7ac9b2f8<span class="built_in">cd</span>7:/<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="comment"># docker commit -m "add node evn" -a "haiyue" d7ac9b2f8cd7 haiyue/nodejs:v1</span></span><br><span class="line">sha256:<span class="number">23</span>c1c51f86414ae2ab3bf31f192537e6635c248044b61802c9e553ef4e46fbf9</span><br><span class="line"><span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">haiyue/nodejs       v1                  <span class="number">23</span>c1c51f8641        <span class="number">10</span> seconds ago      <span class="number">162.4</span> MB</span><br><span class="line">docker.io/ubuntu    <span class="number">12.04</span>               e216a057b1cb        <span class="number">12</span> days ago         <span class="number">103.6</span> MB</span><br></pre></td></tr></table></figure>
<p>-m 来指定提交的说明信息；-a 可以指定更新的用户信息；之后是用来创建镜像的容器的 ID；最后指定目标镜像的仓库名和 tag 信息。创建成功后会返回这个镜像的 ID 信息。</p>
<ul>
<li>利用 Dockerfile 来创建镜像<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mkdir haiyue</span></span><br><span class="line"><span class="comment"># cd haiyue/</span></span><br><span class="line"><span class="comment"># This is a comment</span></span><br><span class="line"><span class="comment"># vim Dockerfile</span></span><br><span class="line">FROM docker.io/ubuntu:<span class="number">12.04</span></span><br><span class="line">MAINTAINER haiyue</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install nodejs</span><br><span class="line"><span class="comment"># docker build -t="haiyue/nodejs:v2" .</span></span><br><span class="line"><span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">haiyue/nodejs       v2                  <span class="number">5190</span>c35<span class="built_in">fc</span>391        <span class="number">4</span> seconds ago       <span class="number">103.6</span> MB</span><br><span class="line">haiyue/nodejs       v1                  <span class="number">23</span>c1c51f8641        <span class="number">2</span> hours ago         <span class="number">162.4</span> MB</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Dockerfile 基本的语法是</span><br><span class="line"><span class="preprocessor">#: 注释</span></span><br><span class="line"><span class="label">FROM:</span> 告诉 Docker 使用哪个镜像作为基础</span><br><span class="line"><span class="label">MAINTAINER:</span> 维护者的信息</span><br><span class="line"><span class="label">RUN:</span> 指令会在创建中运行</span><br><span class="line"></span><br><span class="line">build 指令后 -t 标记来添加 tag，指定新的镜像的用户信息。 “.” 是 Dockerfile 所在的路径（当前目录），也可以替换为一个具体的 Dockerfile 的路径。</span><br><span class="line"></span><br><span class="line">*注意一个镜像不能超过 <span class="number">127</span> 层</span><br></pre></td></tr></table></figure>
<ul>
<li>上传镜像(推送自己的镜像到仓库, Docker Hub)<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker push haiyue/nodejs</span></span><br><span class="line">The push refers to a repository [haiyue/nodejs] (len: <span class="number">1</span>)</span><br><span class="line">Sending image list</span><br><span class="line">Pushing repository haiyue/nodejs (<span class="number">2</span> tags)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="存出和载入镜像">存出和载入镜像</h3><ul>
<li>存出镜像</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker save -o nodejs_v1.tar haiyue/nodejs:v1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>载入镜像</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker load &lt; nodejs_v1.tar</span></span><br></pre></td></tr></table></figure>
<h3 id="移除">移除</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker rmi haiyue/nodejs:v2</span></span><br><span class="line">Untagged: haiyue/nodejs:v2</span><br><span class="line">Deleted: sha256:<span class="number">5190</span>c35<span class="built_in">fc</span>391b6e9b3ed228a60a8342887fb555efcbb8a7bc351badfbb306550</span><br><span class="line">Deleted: sha256:<span class="number">01</span>e2<span class="built_in">cd</span>409ed3b15a1c34a2<span class="built_in">cd</span>656772f51e472ec988b2011ec7d60de3a23e3111</span><br><span class="line">Deleted: sha256:daf78048142d52646c96e8ac025ea5d034270e15cab677838638767b00cb908e</span><br><span class="line"><span class="comment"># docker rmi 23c1c51f8641</span></span><br><span class="line">Failed to remove image (<span class="number">23</span>c1c51f8641): Error response from daemon: conflict: unable to delete <span class="number">23</span>c1c51f8641 (must be forced) - image is being used by stopped container <span class="number">1586</span>df1c5dc1</span><br><span class="line"><span class="comment"># docker rmi -f 23c1c51f8641</span></span><br><span class="line">Untagged: haiyue/nodejs:v1</span><br></pre></td></tr></table></figure>
<h2 id="容器">容器</h2><h3 id="启动-1">启动</h3><ul>
<li>新建并启动<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker run haiyue/nodejs:v1 /bin/echo 'Hello world'</span></span><br><span class="line">Hello world</span><br><span class="line"><span class="comment"># docker run -t -i haiyue/nodejs:v1 /bin/bash</span></span><br><span class="line">root@<span class="number">66230</span>fd659ff:/<span class="comment"># node -v</span></span><br><span class="line">v0.<span class="number">6.12</span></span><br><span class="line">root@<span class="number">66230</span>fd659ff:/<span class="comment"># ls</span></span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  selinux  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">t 让<span class="constant">Docker</span>分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上 </span><br><span class="line"></span>-<span class="ruby">i 则让容器的标准输入保持打开。</span><br><span class="line"></span></span><br><span class="line">docker run 来创建容器时，Docker 在后台运行的标准操作包括：</span><br><span class="line">检查本地是否存在指定的镜像，不存在就从公有仓库下载</span><br><span class="line">利用镜像创建并启动一个容器</span><br><span class="line">分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</span><br><span class="line">从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</span><br><span class="line">从地址池配置一个 ip 地址给容器</span><br><span class="line">执行用户指定的应用程序</span><br><span class="line">执行完毕后容器被终止</span><br></pre></td></tr></table></figure>
<ul>
<li>启动已终止容器<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">利用 docker <span class="literal">start</span> 命令，直接将一个已经终止的容器启动运行。</span><br><span class="line">docker <span class="literal">restart</span> 命令会将一个运行态的容器终止，然后再重新启动它。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="守护态运行">守护态运行</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker run -d haiyue/nodejs:v1 /bin/sh -c "while true; do echo hello world; sleep 1; done"</span></span><br><span class="line"><span class="number">90</span>a4f5809293e21f8eacf1945668b9076e68ed500ac3d3018<span class="built_in">fc</span>902d947f57248</span><br><span class="line"><span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line"><span class="number">90</span>a4f5809293        haiyue/nodejs:v1    <span class="string">"/bin/sh -c 'while tr"</span>   <span class="number">9</span> seconds ago       Up <span class="number">8</span> seconds                            determined_sammet</span><br><span class="line"><span class="comment"># docker logs 90a4f5809293</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<h3 id="终止容器">终止容器</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line"><span class="number">90</span>a4f5809293        haiyue/nodejs:v1    <span class="string">"/bin/sh -c 'while tr"</span>   <span class="number">2</span> minutes ago       Up <span class="number">2</span> minutes                            determined_sammet</span><br><span class="line"><span class="comment"># docker stop 90a4f5809293</span></span><br><span class="line"><span class="number">90</span>a4f5809293</span><br><span class="line"><span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                        PORTS               NAMES</span><br><span class="line"><span class="number">90</span>a4f5809293        haiyue/nodejs:v1    <span class="string">"/bin/sh -c 'while tr"</span>   <span class="number">3</span> minutes ago       Exited (<span class="number">137</span>) <span class="number">37</span> seconds ago                       determined_sammet</span><br></pre></td></tr></table></figure>
<h3 id="进入容器">进入容器</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker attach 90a4f5809293</span></span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>
<h3 id="导出和导入容器">导出和导入容器</h3><ul>
<li>导出容器</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker export 90a4f5809293 &gt; determined_sammet.tar</span></span><br><span class="line"><span class="comment"># ls</span></span><br><span class="line">determined_sammet.tar</span><br></pre></td></tr></table></figure>
<ul>
<li>导入容器快照(容器快照文件中再导入为镜像)</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">haiyue/nodejs       v1                  <span class="number">23</span>c1c51f8641        <span class="number">3</span> hours ago         <span class="number">162.4</span> MB</span><br><span class="line">docker.io/ubuntu    <span class="number">12.04</span>               e216a057b1cb        <span class="number">12</span> days ago         <span class="number">103.6</span> MB</span><br><span class="line"><span class="comment"># cat determined_sammet.tar | docker import - haiyue/nodejs:v2</span></span><br><span class="line">sha256:<span class="number">7</span>b78999d774ccb41d474fb2c851323191967593053a26982c11157c7621e9202</span><br><span class="line"><span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">haiyue/nodejs       v2                  <span class="number">7</span>b78999d774c        <span class="number">3</span> seconds ago       <span class="number">142.1</span> MB</span><br><span class="line">haiyue/nodejs       v1                  <span class="number">23</span>c1c51f8641        <span class="number">3</span> hours ago         <span class="number">162.4</span> MB</span><br><span class="line">docker.io/ubuntu    <span class="number">12.04</span>               e216a057b1cb        <span class="number">12</span> days ago         <span class="number">103.6</span> MB</span><br></pre></td></tr></table></figure>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker <span class="preprocessor"><span class="keyword">import</span> 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</span></span><br></pre></td></tr></table></figure>
<ul>
<li>删除</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">可以使用 docker rm 来删除一个处于终止状态的容器。</span><br><span class="line">如果要删除一个运行中的容器，可以添加 <span class="operator">-f</span> 参数。Docker 会发送 SIGKILL 信号给容器。</span><br></pre></td></tr></table></figure>
<p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="查看linux版本">查看linux版本</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ lsb_release <span class="operator">-a</span></span><br><span class="line">LSB Version:    :core-<span class="number">4.1</span>-amd64:core-<span class="number">4.1</span>-noarch</span><br><span class="line">Distributor ID: CentOS</span><br><span class="line">Description:    CentOS Linux release <span class="number">7.2</span>.<span class="number">1511</span> (Core)</span><br><span class="line">Release:    <span class="number">7.2</span>.<span class="number">1511</span></span><br><span class="line">Codename:   Core</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="Docker" scheme="http://www.haiyue.me/tags/Docker/"/>
    
      <category term="编程" scheme="http://www.haiyue.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Nginx 安装]]></title>
    <link href="http://www.haiyue.me/2016/09/06/nginx-install/"/>
    <id>http://www.haiyue.me/2016/09/06/nginx-install/</id>
    <published>2016-09-05T16:00:00.000Z</published>
    <updated>2016-09-06T10:41:21.000Z</updated>
    <content type="html"><![CDATA[<h2 id="安装编译工具及库文件">安装编译工具及库文件</h2><ul>
<li>切换到root用户下面</li>
<li>yum -y install make zlib zlib-devel gcc-c++ libtool  openssl openssl-devel</li>
</ul>
<a id="more"></a>   
<h2 id="安装_PCRE">安装 PCRE</h2><ul>
<li>PCRE 作用是让 Ngnix 支持 Rewrite 功能。</li>
<li>wget <a href="http://downloads.sourceforge.net/project/pcre/pcre/8.35/pcre-8.35.tar.gz" target="_blank" rel="external">http://downloads.sourceforge.net/project/pcre/pcre/8.35/pcre-8.35.tar.gz</a></li>
<li>tar zxvf pcre-8.35.tar.gz</li>
<li>cd pcre-8.35</li>
<li>./configure</li>
<li>make &amp;&amp; make install</li>
<li>pcre-config —version</li>
</ul>
<h2 id="安装_Nginx">安装 Nginx</h2><ul>
<li>wget <a href="http://nginx.org/download/nginx-1.6.2.tar.gz" target="_blank" rel="external">http://nginx.org/download/nginx-1.6.2.tar.gz</a></li>
<li>tar zxvf nginx-1.6.2.tar.gz</li>
<li>cd nginx-1.6.2</li>
<li>./configure —with-http_stub_status_module —with-http_ssl_module —with-pcre</li>
<li>make &amp;&amp; make install</li>
<li>/usr/local/nginx/sbin/nginx -v</li>
</ul>
<h2 id="Nginx_配置">Nginx 配置</h2><ul>
<li>配置nginx.conf</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">将/usr/<span class="built_in">local</span>/nginx/conf/nginx.conf替换为以下内容</span><br><span class="line"></span><br><span class="line">user  liuhaiming liuhaiming;</span><br><span class="line">worker_processes  <span class="number">4</span>; <span class="comment"># 设置值和CPU核心数一致</span></span><br><span class="line">error_<span class="built_in">log</span> /usr/<span class="built_in">local</span>/nginx/logs/nginx_error.log notice; <span class="comment">#日志位置和日志级别</span></span><br><span class="line">pid        /usr/<span class="built_in">local</span>/nginx/logs/nginx.pid;</span><br><span class="line"><span class="comment">#Specifies the value for maximum file descriptors that can be opened by this process.</span></span><br><span class="line">worker_rlimit_nofile <span class="number">65535</span>;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">        use epoll;</span><br><span class="line">        worker_connections <span class="number">65535</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">        include       mime.types;</span><br><span class="line">        default_<span class="built_in">type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">log</span>_format  main  <span class="string">'$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">                      <span class="string">'$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">                      <span class="string">'"$http_user_agent" "$http_x_forwarded_for"'</span>;</span><br><span class="line"></span><br><span class="line">        server_names_<span class="built_in">hash</span>_bucket_size <span class="number">128</span>;</span><br><span class="line">        client_header_buffer_size <span class="number">32</span>k;</span><br><span class="line">        large_client_header_buffers <span class="number">4</span> <span class="number">32</span>k;</span><br><span class="line">        client_max_body_size <span class="number">8</span>m;</span><br><span class="line"></span><br><span class="line">        sendfile        on;</span><br><span class="line">        tcp_nopush on;</span><br><span class="line">        keepalive_timeout <span class="number">60</span>;</span><br><span class="line">        tcp_nodelay on;</span><br><span class="line">        fastcgi_connect_timeout <span class="number">300</span>;</span><br><span class="line">        fastcgi_send_timeout <span class="number">300</span>;</span><br><span class="line">        fastcgi_<span class="built_in">read</span>_timeout <span class="number">300</span>;</span><br><span class="line">        fastcgi_buffer_size <span class="number">64</span>k;</span><br><span class="line">        fastcgi_buffers <span class="number">4</span> <span class="number">64</span>k;</span><br><span class="line">        fastcgi_busy_buffers_size <span class="number">128</span>k;</span><br><span class="line">        fastcgi_temp_file_write_size <span class="number">128</span>k;</span><br><span class="line">        gzip on;</span><br><span class="line">        gzip_min_length <span class="number">1</span>k;</span><br><span class="line">        gzip_buffers <span class="number">4</span> <span class="number">16</span>k;</span><br><span class="line">        gzip_http_version <span class="number">1.0</span>;</span><br><span class="line">        gzip_comp_level <span class="number">2</span>;</span><br><span class="line">        gzip_types text/plain application/x-javascript text/css application/xml;</span><br><span class="line">        gzip_vary on;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#下面是server虚拟主机的配置</span></span><br><span class="line">        server &#123;</span><br><span class="line">                listen       <span class="number">80</span>; <span class="comment"># 监听端口</span></span><br><span class="line">                server_name  localhost; <span class="comment"># 域名</span></span><br><span class="line"></span><br><span class="line">                charset utf-<span class="number">8</span>;</span><br><span class="line">                access_<span class="built_in">log</span>  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">                error_page   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /<span class="number">50</span>x.html;</span><br><span class="line">                location = /<span class="number">50</span>x.html &#123;</span><br><span class="line">                        root   html;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>检查配置文件ngnix.conf的正确性: /usr/local/nginx/sbin/nginx -t</li>
<li>启动 Nginx: /usr/local/nginx/sbin/nginx</li>
<li>访问站点: <a href="http://182.92.109.136/" target="_blank" rel="external">http://182.92.109.136/</a></li>
</ul>
<h2 id="Nginx_其他命令">Nginx 其他命令</h2><ul>
<li>/usr/local/nginx/sbin/nginx -s reload            # 重新载入配置文件</li>
<li>/usr/local/nginx/sbin/nginx -s reopen            # 重启 Nginx</li>
<li>/usr/local/nginx/sbin/nginx -s stop              # 停止 Nginx</li>
</ul>
<h2 id="常用指令说明">常用指令说明</h2><h3 id="main全局配置">main全局配置</h3><ul>
<li>nginx在运行时与具体业务功能（比如http服务或者email服务代理）无关的一些参数，比如工作进程数，运行的身份等。  </li>
<li>woker_processes 4 在配置文件的顶级main部分，worker角色的工作进程的个数，master进程是接收并分配请求给worker处理。这个数值简单一点可以设置为cpu的核数(grep ^processor /proc/cpuinfo | wc -l)，也是 auto 值，如果开启了ssl和gzip更应该设置成与逻辑CPU数量一样甚至为2倍，可以减少I/O操作。如果nginx服务器还有其它服务，可以考虑适当减少。</li>
<li>worker_cpu_affinity 也是写在main部分。在高并发情况下，通过设置cpu粘性来降低由于多CPU核切换造成的寄存器等现场重建带来的性能损耗。如worker_cpu_affinity 0001 0010 0100 1000; （四核）。</li>
<li>worker_connections 2048 写在events部分。每一个worker进程能并发处理（发起）的最大连接数（包含与客户端或后端被代理服务器间等所有连接数）。nginx作为反向代理服务器，计算公式 最大连接数 = worker_processes * worker_connections/4，所以这里客户端最大连接数是1024，这个可以增到到8192都没关系，看情况而定，但不能超过后面的worker_rlimit_nofile。当nginx作为http服务器时，计算公式里面是除以2。</li>
<li>worker_rlimit_nofile 10240 写在main部分。默认是没有设置，可以限制为操作系统最大的限制65535。</li>
<li>use epoll 写在events部分。在Linux操作系统下，nginx默认使用epoll事件模型，得益于此，nginx在Linux操作系统下效率相当高。同时Nginx在OpenBSD或FreeBSD操作系统上采用类似于epoll的高效事件模型kqueue。在操作系统不支持这些高效模型时才使用select。</li>
</ul>
<h3 id="http服务器">http服务器</h3><ul>
<li>与提供http服务相关的一些配置参数。例如：是否使用keepalive啊，是否使用gzip进行压缩等。</li>
<li>sendfile on 开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，减少用户空间到内核空间的上下文切换。对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。</li>
<li>keepalive_timeout 65 长连接超时时间，单位是秒，这个参数很敏感，涉及浏览器的种类、后端服务器的超时设置、操作系统的设置，可以另外起一片文章了。长连接请求大量小文件的时候，可以减少重建连接的开销，但假如有大文件上传，65s内没上传完成会导致失败。如果设置时间过长，用户又多，长时间保持连接会占用大量资源。</li>
<li>send_timeout 用于指定响应客户端的超时时间。这个超时仅限于两个连接活动之间的时间，如果超过这个时间，客户端没有任何活动，Nginx将会关闭连接。</li>
<li>client_max_body_size 10m 允许客户端请求的最大单文件字节数。如果有上传较大文件，请设置它的限制值</li>
<li>client_body_buffer_size 128k 缓冲区代理缓冲用户端请求的最大字节数</li>
</ul>
<h3 id="模块http_proxy">模块http_proxy</h3><ul>
<li>这个模块实现的是nginx作为反向代理服务器的功能，包括缓存功能</li>
<li>proxy_connect_timeout 60 nginx跟后端服务器连接超时时间(代理连接超时)</li>
<li>proxy_read_timeout 60 连接成功后，与后端服务器两个成功的响应操作之间超时时间(代理接收超时)</li>
<li>proxy_buffer_size 4k 设置代理服务器（nginx）从后端realserver读取并保存用户头信息的缓冲区大小，默认与proxy_buffers大小相同，其实可以将这个指令值设的小一点</li>
<li>proxy_buffers 4 32k proxy_buffers缓冲区，nginx针对单个连接缓存来自后端realserver的响应，网页平均在32k以下的话，这样设置</li>
<li>proxy_busy_buffers_size 64k 高负荷下缓冲大小（proxy_buffers*2）</li>
<li>proxy_max_temp_file_size 当proxy_buffers放不下后端服务器的响应内容时，会将一部分保存到硬盘的临时文件中，这个值用来设置最大临时文件大小，默认1024M，它与proxy_cache没有关系。大于这个值，将从upstream服务器传回。设置为0禁用。</li>
<li>proxy_temp_file_write_size 64k 当缓存被代理的服务器响应到临时文件时，这个选项限制每次写临时文件的大小。proxy_temp_path（可以在编译的时候）指定写到哪那个目录。</li>
<li>proxy_pass，proxy_redirect见 location 部分。</li>
</ul>
<h3 id="模块http_gzip">模块http_gzip</h3><ul>
<li>gzip on : 开启gzip压缩输出，减少网络传输。</li>
<li>gzip_min_length 1k ： 设置允许压缩的页面最小字节数，页面字节数从header头得content-length中进行获取。默认值是20。建议设置成大于1k的字节数，小于1k可能会越压越大。</li>
<li>gzip_buffers 4 16k ： 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。4 16k代表以16k为单位，安装原始数据大小以16k为单位的4倍申请内存。</li>
<li>gzip_http_version 1.0 ： 用于识别 http 协议的版本，早期的浏览器不支持 Gzip 压缩，用户就会看到乱码，所以为了支持前期版本加上了这个选项，如果你用了 Nginx 的反向代理并期望也启用 Gzip 压缩的话，由于末端通信是 http/1.0，故请设置为 1.0。</li>
<li>gzip_comp_level 6 ： gzip压缩比，1压缩比最小处理速度最快，9压缩比最大但处理速度最慢(传输快但比较消耗cpu)</li>
<li>gzip_types ：匹配mime类型进行压缩，无论是否指定,”text/html”类型总是会被压缩的。</li>
<li>gzip_proxied any ： Nginx作为反向代理的时候启用，决定开启或者关闭后端服务器返回的结果是否压缩，匹配的前提是后端服务器必须要返回包含”Via”的 header头。</li>
<li>gzip_vary on ： 和http头有关系，会在响应头加个 Vary: Accept-Encoding ，可以让前端的缓存服务器缓存经过gzip压缩的页面，例如，用Squid缓存经过Nginx压缩的数据。。</li>
</ul>
<h3 id="server虚拟主机">server虚拟主机</h3><ul>
<li>http服务上支持若干虚拟主机。每个虚拟主机一个对应的server配置项，配置项里面包含该虚拟主机相关的配置。在提供mail服务的代理时，也可以建立若干server。每个server通过监听地址或端口来区分。</li>
<li>listen 监听端口，默认80，小于1024的要以root启动。可以为listen *:80、listen 127.0.0.1:80等形式。</li>
<li>server_name 服务器名，如localhost、www.example.com，可以通过正则匹配。</li>
</ul>
<h3 id="模块http_stream">模块http_stream</h3><ul>
<li>这个模块通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡，upstream后接负载均衡器的名字，后端realserver以 host:port options; 方式组织在 {} 中。如果后端被代理的只有一台，也可以直接写在 proxy_pass 。</li>
</ul>
<h3 id="location">location</h3><ul>
<li>http服务中，某些特定的URL对应的一系列配置项。</li>
<li>root /var/www/html 定义服务器的默认网站根目录位置。如果locationURL匹配的是子目录或文件，root没什么作用，一般放在server指令里面或/下。</li>
<li>index index.jsp index.html index.htm 定义路径下默认访问的文件名，一般跟着root放</li>
<li>proxy_pass http:/backend 请求转向backend定义的服务器列表，即反向代理，对应upstream负载均衡器。也可以proxy_pass <a href="http://ip:port。" target="_blank" rel="external">http://ip:port。</a></li>
</ul>
<p>原文链接</p>
<ul>
<li><a href="http://www.runoob.com/linux/nginx-install-setup.html" target="_blank" rel="external">http://www.runoob.com/linux/nginx-install-setup.html</a></li>
<li><a href="https://segmentfault.com/a/1190000002797601#articleHeader7" target="_blank" rel="external">https://segmentfault.com/a/1190000002797601#articleHeader7</a></li>
</ul>
<p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="安装编译工具及库文件">安装编译工具及库文件</h2><ul>
<li>切换到root用户下面</li>
<li>yum -y install make zlib zlib-devel gcc-c++ libtool  openssl openssl-devel</li>
</ul>]]>
    
    </summary>
    
      <category term="Nginx" scheme="http://www.haiyue.me/tags/Nginx/"/>
    
      <category term="笔记" scheme="http://www.haiyue.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Node.js中用escape解决sql注入]]></title>
    <link href="http://www.haiyue.me/2016/07/05/escape/"/>
    <id>http://www.haiyue.me/2016/07/05/escape/</id>
    <published>2016-07-04T16:00:00.000Z</published>
    <updated>2016-07-05T07:27:28.000Z</updated>
    <content type="html"><![CDATA[<h3 id="直接拼写sql进行数据库的操作时，很容易被人在动态参数中加入特殊字符产生sql注入，威胁数据库的安全。">直接拼写sql进行数据库的操作时，很容易被人在动态参数中加入特殊字符产生sql注入，威胁数据库的安全。</h3><pre><code class="js"><span class="pi">'use strict'</span>;

<span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql'</span>);

<span class="keyword">let</span> param = <span class="string">'ns'</span>;
<span class="keyword">let</span> pool = mysql.createPool({
  user: <span class="string">'root'</span>,
  password: <span class="string">'root'</span>,
  database: <span class="string">'nlp_dict'</span>
});

pool.getConnection(<span class="function"><span class="keyword">function</span> <span class="params">(err, conn)</span> </span>{
  <span class="keyword">let</span> sql = <span class="string">'select * from tb_nature where nature = "'</span> + param + <span class="string">'" and del_status=1'</span>;
  conn.query(sql, <span class="function"><span class="keyword">function</span> <span class="params">(err, result)</span> </span>{
    <span class="built_in">console</span>.log(result);
  })
});
</code></pre>
<a id="more"></a>
<p>这时正常情况下能查询到一条数据，如果将param修改成<br>let param = ‘ns”— ‘;<br>sql语句就会变成<br>select * from tb_nature where nature = “ns”— “ and del_status=1<br>后面的del_status就会被参数中的 — 注释掉，失去作用，能查询到多条数据。  </p>
<p>如果对param使用escape包装下，就能将参数中的特殊字符进行转义，防止sql的注入。<br>let sql = ‘select * from tb_nature where nature = ‘ +  mysql.escape(param) + ‘ and del_status=1’;</p>
<p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="直接拼写sql进行数据库的操作时，很容易被人在动态参数中加入特殊字符产生sql注入，威胁数据库的安全。">直接拼写sql进行数据库的操作时，很容易被人在动态参数中加入特殊字符产生sql注入，威胁数据库的安全。</h3><pre><code class="js"><span class="pi">'use strict'</span>;

<span class="keyword">const</span> mysql = <span class="built_in">require</span>(<span class="string">'mysql'</span>);

<span class="keyword">let</span> param = <span class="string">'ns'</span>;
<span class="keyword">let</span> pool = mysql.createPool({
  user: <span class="string">'root'</span>,
  password: <span class="string">'root'</span>,
  database: <span class="string">'nlp_dict'</span>
});

pool.getConnection(<span class="function"><span class="keyword">function</span> <span class="params">(err, conn)</span> </span>{
  <span class="keyword">let</span> sql = <span class="string">'select * from tb_nature where nature = "'</span> + param + <span class="string">'" and del_status=1'</span>;
  conn.query(sql, <span class="function"><span class="keyword">function</span> <span class="params">(err, result)</span> </span>{
    <span class="built_in">console</span>.log(result);
  })
});
</code></pre>]]>
    
    </summary>
    
      <category term="Node.js" scheme="http://www.haiyue.me/tags/Node-js/"/>
    
      <category term="编程" scheme="http://www.haiyue.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android 基础]]></title>
    <link href="http://www.haiyue.me/2016/05/28/android-base/"/>
    <id>http://www.haiyue.me/2016/05/28/android-base/</id>
    <published>2016-05-27T16:00:00.000Z</published>
    <updated>2016-06-28T06:56:43.000Z</updated>
    <content type="html"><![CDATA[<h3 id="Android_开发的基本环境">Android 开发的基本环境</h3><ul>
<li>JDK (Java Development Kit)  </li>
<li>IDE (Android Studio)  </li>
<li>Android SDK (Android Software Development Kit)  </li>
<li>ADT (Android Development Tools)  </li>
</ul>
<a id="more"></a>
<h3 id="ADT_和_Android_SDK的区别">ADT 和 Android SDK的区别</h3><ul>
<li>ADT(Android Development Tools)： 目前Android开发所用的开发工具是Eclipse，在Eclipse编译IDE环境中，安装ADT，为Android开发提供开发工具的升级或者变更，简单理解为在Eclipse下开发工具的升级下载工具。ADT只是一个Eclipse的插件，里面可以设置sdk路径。     </li>
<li>SDK(Software Development Kit)： 一般是一些被软件工程师用于为特定的软件包、软件框架、硬件平台、操作系统等建立应用软件的开发工具的集合。在Android中，他为开发者提供了库文件以及其他开发所用到的工具。简单理解为开发工具包集合，是整体开发中所用到的工具包，如果你不用Eclipse作为你的开发工具，你就不需要下载ADT，只下载SDK即可开发。  </li>
</ul>
<h3 id="JDK_和_JRE的区别">JDK 和 JRE的区别</h3><ul>
<li>JRE(Java Runtime Environment): 顾名思义是java运行时环境，包含了java虚拟机，java基础类库。是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的。  </li>
<li>JDK(Java Development Kit): 顾名思义是java开发工具包，是程序员使用java语言编写java程序所需的开发工具包，是提供给程序员使用的。</li>
<li>JDK包含了JRE，同时还包含了编译java源码的编译器javac，还包含了很多java程序调试和分析的工具：jconsole，jvisualvm等工具软件，还包含了java程序编写所需的文档和demo例子程序。如果你需要运行java程序，只需安装JRE就可以了。如果你需要编写java程序，需要安装JDK。</li>
</ul>
<h3 id="Android项目目录结构">Android项目目录结构</h3><ul>
<li>src    放java代码的目录</li>
<li>gen    目录下的文件是编译器生成</li>
<li>assets 资源目录，例如音频、图片、xml（不一定要打入apk包中）</li>
<li>bin    存放编译后的.class .dex  .apk文件的目录，编译器生成</li>
<li>libs    放第三方jar包</li>
<li><p>res    资源目录 （都要打入apk包中）</p>
<ul>
<li><p>drawable（根据名字存放不同分辨率的图片，Android系统为了适配移动设备会根据设备的DPI去对应的目录选择图片）</p>
<ul>
<li>Drawable-hdpi 存放高分辨率图片；</li>
<li>Drawable-ldpi 存放低分辨率图片；</li>
<li>Drawable-mdpi 存放中分辨率图片；</li>
<li>Drawable-xhdpi 存放中高分辨率图片；</li>
<li>Drawable-xhdpi 存放特高分辨率图片。</li>
</ul>
</li>
<li><p>layout 布局文件，Android系统为了使控制层和View层做分离，对一些静态的界面尽量写成xml文件的形式放在Layout文件夹下。</p>
</li>
<li>menu 存放菜单文件</li>
<li>values 存放文字信息配置<ul>
<li>dimens.xml文件存放一些尺寸信息，为了适配屏幕用；</li>
<li>string.xml文件存放文本信息；</li>
<li>styles.xml 文件中定义了一些属性集，方便复用和修改。</li>
</ul>
</li>
<li>AndroidManifest.xml 清单文件，这个文件列出了应用程序所提供的功能，需要什么权限，用到那些服务，当前应用的版本，最低支持android版本，应用的名称、图标和包名，有那些组件，每个组件的配置信息</li>
</ul>
</li>
</ul>
<p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="Android_开发的基本环境">Android 开发的基本环境</h3><ul>
<li>JDK (Java Development Kit)  </li>
<li>IDE (Android Studio)  </li>
<li>Android SDK (Android Software Development Kit)  </li>
<li>ADT (Android Development Tools)  </li>
</ul>]]>
    
    </summary>
    
      <category term="Android" scheme="http://www.haiyue.me/tags/Android/"/>
    
      <category term="笔记" scheme="http://www.haiyue.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[sql 操作]]></title>
    <link href="http://www.haiyue.me/2016/05/26/sql/"/>
    <id>http://www.haiyue.me/2016/05/26/sql/</id>
    <published>2016-05-25T16:00:00.000Z</published>
    <updated>2016-05-26T09:49:12.000Z</updated>
    <content type="html"><![CDATA[<p>删除重复的数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">delete</span> a <span class="keyword">from</span> tb_dict a</span><br><span class="line"><span class="keyword">where</span> (a.keyword,a.nature) <span class="keyword">in</span> (</span><br><span class="line">	<span class="keyword">select</span> * <span class="keyword">from</span> (<span class="keyword">select</span> keyword,nature <span class="keyword">from</span> tb_dict <span class="keyword">group</span> <span class="keyword">by</span> keyword, nature <span class="keyword">having</span> <span class="keyword">count</span>(*) &gt; <span class="number">1</span>) b</span><br><span class="line">) </span><br><span class="line"><span class="keyword">and</span> a.id <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">	<span class="keyword">select</span> * <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">min</span>(id) <span class="keyword">from</span> tb_dict <span class="keyword">group</span> <span class="keyword">by</span> keyword, nature <span class="keyword">having</span> <span class="keyword">count</span>(*)&gt;<span class="number">1</span>) c</span><br><span class="line">)</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>      
<p>查询重复的数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> * <span class="keyword">from</span> tb_dict a </span><br><span class="line"><span class="keyword">where</span> (a.keyword,a.nature, a.freq) <span class="keyword">in</span> (</span><br><span class="line">	<span class="keyword">select</span> keyword,nature, freq <span class="keyword">from</span> tb_dict <span class="keyword">group</span> <span class="keyword">by</span> keyword, nature, freq <span class="keyword">having</span> <span class="keyword">count</span>(*) &gt; <span class="number">1</span></span><br><span class="line">)</span></span><br></pre></td></tr></table></figure>
<p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>删除重复的数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">delete</span> a <span class="keyword">from</span> tb_dict a</span><br><span class="line"><span class="keyword">where</span> (a.keyword,a.nature) <span class="keyword">in</span> (</span><br><span class="line">	<span class="keyword">select</span> * <span class="keyword">from</span> (<span class="keyword">select</span> keyword,nature <span class="keyword">from</span> tb_dict <span class="keyword">group</span> <span class="keyword">by</span> keyword, nature <span class="keyword">having</span> <span class="keyword">count</span>(*) &gt; <span class="number">1</span>) b</span><br><span class="line">) </span><br><span class="line"><span class="keyword">and</span> a.id <span class="keyword">not</span> <span class="keyword">in</span> (</span><br><span class="line">	<span class="keyword">select</span> * <span class="keyword">from</span> (<span class="keyword">select</span> <span class="keyword">min</span>(id) <span class="keyword">from</span> tb_dict <span class="keyword">group</span> <span class="keyword">by</span> keyword, nature <span class="keyword">having</span> <span class="keyword">count</span>(*)&gt;<span class="number">1</span>) c</span><br><span class="line">)</span></span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="sql" scheme="http://www.haiyue.me/tags/sql/"/>
    
      <category term="编程" scheme="http://www.haiyue.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mysql 批量删除错误分析]]></title>
    <link href="http://www.haiyue.me/2016/05/26/mysql-batch-delete/"/>
    <id>http://www.haiyue.me/2016/05/26/mysql-batch-delete/</id>
    <published>2016-05-25T16:00:00.000Z</published>
    <updated>2016-05-26T08:08:12.000Z</updated>
    <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">delete</span> t1 <span class="keyword">from</span> tb_dict t1 </span><br><span class="line"><span class="keyword">where</span> t1.id <span class="keyword">in</span> (</span><br><span class="line">	<span class="keyword">select</span> t2.id <span class="keyword">from</span> tb_dict t2 <span class="keyword">where</span> t2.nature = <span class="string">'v-taxi'</span></span><br><span class="line">);</span></span><br></pre></td></tr></table></figure>
<p>使用这条 sql 语句进行批量删除时报 “You can’t specify target table ‘t1’ for update in FROM clause” 错误，查询后得知原来 msyql 不允许在子查询的同时删除原表中的数据。下面对应的解决办法。</p>
<pre><code class="sql"><span class="operator"><span class="keyword">delete</span> t1 <span class="keyword">from</span> tb_dict t1 
<span class="keyword">where</span> t1.id <span class="keyword">in</span> (
    <span class="keyword">select</span> t3.id <span class="keyword">from</span> (
        <span class="keyword">select</span> * <span class="keyword">from</span> tb_dict t2 <span class="keyword">where</span> t2.nature = <span class="string">'v-taxi'</span>
    ) <span class="keyword">as</span> t3
);</span>
</code></pre>
<p>将子查询得到的数据封装成临时表，这时就能解决问题了。</p>
<p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="]]>
    </summary>
    
      <category term="sql" scheme="http://www.haiyue.me/tags/sql/"/>
    
      <category term="编程" scheme="http://www.haiyue.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[List 进行 remove 操作时抛出 java.lang.UnsupportedOperationException 异常分析]]></title>
    <link href="http://www.haiyue.me/2016/05/13/UnsupportedOperationException/"/>
    <id>http://www.haiyue.me/2016/05/13/UnsupportedOperationException/</id>
    <published>2016-05-12T16:00:00.000Z</published>
    <updated>2016-05-13T07:47:18.000Z</updated>
    <content type="html"><![CDATA[<p>今天将一个数组转换成 List 然后进行 remove 操作时却抛出 java.lang.UnsupportedOperationException 异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String pattern = <span class="string">" ^, v, m, n-music-name, $ "</span>;</span><br><span class="line">String[] patternSplit = Utils.getStringTrimSplit(pattern, <span class="string">","</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除模式中的^和$标识</span></span><br><span class="line">List&lt;String&gt; natureList = Arrays.asList(patternSplit);</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"^"</span>.equals(natureList.get(<span class="number">0</span>))) &#123;</span><br><span class="line">    natureList.remove(<span class="number">0</span>); <span class="comment">// throw java.lang.UnsupportedOperationException</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"$"</span>.equals(natureList.get(natureList.size() - <span class="number">1</span>))) &#123;</span><br><span class="line">    natureList.remove(natureList.size() - <span class="number">1</span>); <span class="comment">// throw java.lang.UnsupportedOperationException</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String[] natureArray = natureList.toArray(<span class="keyword">new</span> String[natureList.size()]);</span><br><span class="line">System.out.println(natureArray.length);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>看了下源码才发现使用 Arrays.asList(arr) 转换的 List 并不能进行 add 和 remove 操作。<br>Arrays.asList(arr) 返回的类型是 Aarrays$ArrayList 并不是 ArrayList，<br>Aarrays$ArrayList 和 ArrayList 都继承 AbstractList，但是 AbstractList 中的 add 方法和 remove 方法都是直接抛出 UnsupportedOperationException，并没有直接实现。<br>ArrayList 重写了 add 方法和 remove 方法,能够进行对应的添加和删除操作，Aarrays$ArrayList 却没有去重写，所以此时调用 add 方法和 remove   方法会抛出 UnsupportedOperationException。 </p>
<h2 id="解决办法">解决办法</h2><pre><code class="java"><span class="comment">// old</span>
List&lt;String&gt; natureList = Arrays.asList(patternSplit);
<span class="comment">// new </span>
List&lt;String&gt; natureList = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(patternSplit));
</code></pre>
<h2 id="源码">源码</h2><p>Arrays.asList(arr) 返回 Aarrays$ArrayList ， Aarrays$ArrayList 继承 AbstractList<br><img src="http://7xia33.com1.z0.glb.clouddn.com/UnsupportedOperationException1.jpg" alt=""><br>ArrayList 继承 AbstractList<br><img src="http://7xia33.com1.z0.glb.clouddn.com/UnsupportedOperationException2.jpg" alt=""><br>AbstractList 中的 add 方法和 remove 方法都直接抛出 UnsupportedOperationException<br><img src="http://7xia33.com1.z0.glb.clouddn.com/UnsupportedOperationException3.jpg" alt=""><br>ArrayList 重写 add 方法和 remove 方法<br><img src="http://7xia33.com1.z0.glb.clouddn.com/UnsupportedOperationException4.jpg" alt="">   </p>
<p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天将一个数组转换成 List 然后进行 remove 操作时却抛出 java.lang.UnsupportedOperationException 异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String pattern = <span class="string">" ^, v, m, n-music-name, $ "</span>;</span><br><span class="line">String[] patternSplit = Utils.getStringTrimSplit(pattern, <span class="string">","</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除模式中的^和$标识</span></span><br><span class="line">List&lt;String&gt; natureList = Arrays.asList(patternSplit);</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"^"</span>.equals(natureList.get(<span class="number">0</span>))) &#123;</span><br><span class="line">    natureList.remove(<span class="number">0</span>); <span class="comment">// throw java.lang.UnsupportedOperationException</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"$"</span>.equals(natureList.get(natureList.size() - <span class="number">1</span>))) &#123;</span><br><span class="line">    natureList.remove(natureList.size() - <span class="number">1</span>); <span class="comment">// throw java.lang.UnsupportedOperationException</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String[] natureArray = natureList.toArray(<span class="keyword">new</span> String[natureList.size()]);</span><br><span class="line">System.out.println(natureArray.length);</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.haiyue.me/tags/java/"/>
    
      <category term="编程" scheme="http://www.haiyue.me/categories/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[缓存的相关概念和应用]]></title>
    <link href="http://www.haiyue.me/2016/05/11/cache/"/>
    <id>http://www.haiyue.me/2016/05/11/cache/</id>
    <published>2016-05-10T16:00:00.000Z</published>
    <updated>2016-05-11T06:10:11.000Z</updated>
    <content type="html"><![CDATA[<p>一般都是用Redis或者Memcached来做数据的缓存，让程序的读取效率更高，以此缓解数据库的压力。</p>
<h2 id="缓存穿透">缓存穿透</h2><p>原因：我们在项目中使用缓存通常都是先检查缓存中是否存在，如果存在直接返回缓存内容，如果不存在就直接查询数据库然后再缓存查询结果返回。这个时候如果我们查询的某一个数据在缓存中一直不存在，就会造成每一次请求都查询DB，这样缓存就失去了意义，在流量大时，可能DB就挂掉了。有人利用不存在的key频繁攻击我们的应用，这就是漏洞。</p>
<a id="more"></a>
<p>解决办法：可以在查询时将不存在的key预先设定一个值。比如，”key” , “&amp;&amp;”。在返回这个&amp;&amp;值的时候，我们的应用就可以认为这是不存在的key，再次请求这个key，如果取到的值不再是&amp;&amp;，则可以认为这时候key有值了，从而避免了透传到数据库，从而把大量的类似请求挡在了缓存之中。</p>
<h2 id="缓存并发">缓存并发</h2><p>原因：有时候如果网站并发访问高，一个缓存如果失效，可能出现多个进程同时查询DB，同时设置缓存的情况，如果并发确实很大，这也可能造成DB压力过大，还有缓存频繁更新的问题。</p>
<p>解决办法：对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询。</p>
<h2 id="缓存失效">缓存失效</h2><p>原因：高并发的时候，平时我们设定一个缓存的过期时间时，可能有一些会设置1分钟啊，5分钟这些，并发很高时可能会出在某一个时间同时生成了很多的缓存，并且过期时间都一样，这个时候就可能引发一当过期时间到后，这些缓存同时失效，请求全部转发到DB，DB可能会压力过重。</p>
<p>解决办法：将缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p>
<h3 id="总结">总结</h3><p>缓存并发和缓存失效都是在高并发的时候对压力的优化，缓存穿透很有必要在做缓存的时候加上解决的措施。</p>
<p>原文链接：<a href="http://www.jianshu.com/p/d96906140199" target="_blank" rel="external">缓存穿透、缓存并发、缓存失效之思路变迁 - 小程故事多</a>   </p>
<p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一般都是用Redis或者Memcached来做数据的缓存，让程序的读取效率更高，以此缓解数据库的压力。</p>
<h2 id="缓存穿透">缓存穿透</h2><p>原因：我们在项目中使用缓存通常都是先检查缓存中是否存在，如果存在直接返回缓存内容，如果不存在就直接查询数据库然后再缓存查询结果返回。这个时候如果我们查询的某一个数据在缓存中一直不存在，就会造成每一次请求都查询DB，这样缓存就失去了意义，在流量大时，可能DB就挂掉了。有人利用不存在的key频繁攻击我们的应用，这就是漏洞。</p>]]>
    
    </summary>
    
      <category term="java" scheme="http://www.haiyue.me/tags/java/"/>
    
      <category term="笔记" scheme="http://www.haiyue.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[We have a problem with promises]]></title>
    <link href="http://www.haiyue.me/2016/02/23/promises/"/>
    <id>http://www.haiyue.me/2016/02/23/promises/</id>
    <published>2016-02-22T16:00:00.000Z</published>
    <updated>2016-02-23T04:28:23.000Z</updated>
    <content type="html"><![CDATA[<h2 id="下面的四种_promises_的区别是什么">下面的四种 promises 的区别是什么</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> doSomethingElse();  </span><br><span class="line">&#125;);  </span><br><span class="line">  </span><br><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;  </span><br><span class="line">    doSomethingElse();  </span><br><span class="line">&#125;);  </span><br><span class="line">  </span><br><span class="line">doSomething().then(doSomethingElse());  </span><br><span class="line"></span><br><span class="line">doSomething().then(doSomethingElse);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="原文地址链接：http://fex-baidu-com/blog/2015/07/we-have-a-problem-with-promises/">原文地址链接：<a href="http://fex.baidu.com/blog/2015/07/we-have-a-problem-with-promises/" target="_blank" rel="external">http://fex.baidu.com/blog/2015/07/we-have-a-problem-with-promises/</a></h3><p>Puzzle #1</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doSomething</span><br><span class="line">|-----------------|</span><br><span class="line">                  doSomethingElse(<span class="literal">undefined</span>)</span><br><span class="line">                  |------------------|</span><br><span class="line">                                     finalHandler(resultOfDoSomethingElse)</span><br><span class="line">                                     |------------------|</span><br></pre></td></tr></table></figure>
<p>Puzzle #2</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doSomething</span><br><span class="line">|-----------------|</span><br><span class="line">                  doSomethingElse(<span class="literal">undefined</span>)</span><br><span class="line">                  |------------------|</span><br><span class="line">                  finalHandler(<span class="literal">undefined</span>)</span><br><span class="line">                  |------------------|</span><br></pre></td></tr></table></figure>
<p>Puzzle #3</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doSomething</span><br><span class="line">|-----------------|</span><br><span class="line">doSomethingElse(<span class="literal">undefined</span>)</span><br><span class="line">|---------------------------------|</span><br><span class="line">                  finalHandler(resultOfDoSomething)</span><br><span class="line">                  |------------------|</span><br></pre></td></tr></table></figure>
<p>Puzzle #4</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">doSomething</span><br><span class="line">|-----------------|</span><br><span class="line">                  doSomethingElse(resultOfDoSomething)</span><br><span class="line">                  |------------------|</span><br><span class="line">                                     finalHandler(resultOfDoSomethingElse)</span><br><span class="line">                                     |------------------|</span><br></pre></td></tr></table></figure>
<p>Promises 解决了 Callback Hell 问题，并且不仅仅是缩进问题。就像在 《Callback Hell 的救赎》 中描述的一样，回调函数真正的问题在于他剥夺了我们使用 return 和 throw 这些关键字的能力。</p>
<h2 id="Promises的正确的风格">Promises的正确的风格</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">remotedb.allDocs(...).then(<span class="function"><span class="keyword">function</span> <span class="params">(resultOfAllDocs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> localdb.put(...);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="params">(resultOfPut)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> localdb.get(...);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="params">(resultOfGet)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> localdb.put(...);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这种写法被称为 composing promises ，是 promises 的强大能力之一。每一个函数只会在前一个 promise 被调用并且完成回调后调用，并且这个函数会被前一个 promise 的输出调用</p>
<h2 id="用了_promises_后怎么用_forEach?">用了 promises 后怎么用 forEach?</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="comment">// I want to remove() all docs</span></span><br><span class="line">db.allDocs(&#123;include_docs: <span class="literal">true</span>&#125;).then(<span class="function"><span class="keyword">function</span> <span class="params">(result)</span> </span>&#123;</span><br><span class="line">  result.rows.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(row)</span> </span>&#123;</span><br><span class="line">    db.remove(row.doc);  </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// I naively believe all docs have been removed() now!</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line">db.allDocs(&#123;include_docs: <span class="literal">true</span>&#125;).then(<span class="function"><span class="keyword">function</span> <span class="params">(result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Promise.all(result.rows.map(<span class="function"><span class="keyword">function</span> <span class="params">(row)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> db.remove(row.doc);</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="params">(arrayOfResults)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// All docs have really been removed() now!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>一定不要忘记使用 .catch()</p>
<h2 id="catch()_与_then(null,_…)_并非完全等价">catch() 与 then(null, …) 并非完全等价</h2><p>catch() 仅仅是一个语法糖。因此下面两段代码是等价的:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">somePromise().catch(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// handle error</span></span><br><span class="line">&#125;);</span><br><span class="line">somePromise().then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// handle error</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>但是并非完全等价</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oh noes'</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// I caught your error! :)</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oh noes'</span>);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// I didn't catch your error! :(</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="下面的四种_promises_的区别是什么">下面的四种 promises 的区别是什么</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> doSomethingElse();  </span><br><span class="line">&#125;);  </span><br><span class="line">  </span><br><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;  </span><br><span class="line">    doSomethingElse();  </span><br><span class="line">&#125;);  </span><br><span class="line">  </span><br><span class="line">doSomething().then(doSomethingElse());  </span><br><span class="line"></span><br><span class="line">doSomething().then(doSomethingElse);</span><br></pre></td></tr></table></figure>]]>
    
    </summary>
    
      <category term="js" scheme="http://www.haiyue.me/tags/js/"/>
    
      <category term="笔记" scheme="http://www.haiyue.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入浅出ES6笔记]]></title>
    <link href="http://www.haiyue.me/2016/02/18/ES6-in-depth/"/>
    <id>http://www.haiyue.me/2016/02/18/ES6-in-depth/</id>
    <published>2016-02-17T16:00:00.000Z</published>
    <updated>2016-02-18T07:10:27.000Z</updated>
    <content type="html"><![CDATA[<h1 id="ES6_是什么">ES6 是什么</h1><ul>
<li>编程语言 JavaScript 是 ECMAScript 的实现和扩展,由 ECMA(一个类似 W3C 的标准组织)参与进行标准化。   </li>
<li>ES4 饱受争议,当标准委员会最终停止开发 ES4 时,其成员同意发布一个相对谦和的 ES5 版本,随后继续制定一些更具实质性的新特性。这一明确的协商协议最终命 名为“Harmony”(ES6)。  </li>
<li>2009 年发布的改进版本 ES5,引入了 Object.create()、Object.defineProperty()、getters 和 setters、严格模式以及 JSON 对象。  </li>
<li>如果你想在 web 环境中使用这种新语法,同时需要支持 IE 和 Safari, 你可以使用 Babel 或 Google 的 Traceur 这些编译器来将你的 ES6 代码翻译为 Web 友好 的 ES5 代码。  </li>
</ul>
<a id="more"></a>
<h1 id="迭代器和_for-of_循环">迭代器和 for-of 循环</h1><h2 id="遍历数组中的元素">遍历数组中的元素</h2><ul>
<li><p>20 年前 JavaScript 刚萌生时     </p>
<pre><code><span class="keyword">for</span> (var <span class="keyword">index</span> = <span class="number">0</span>; <span class="keyword">index</span> &lt; myArray.<span class="keyword">length</span>; <span class="keyword">index</span>++) { 
    console.<span class="keyword">log</span>(myArray[<span class="keyword">index</span>]);
}
</code></pre></li>
<li><p>ES5 正式发布后  </p>
<pre><code>myArray.forEach(<span class="function"><span class="keyword">function</span> <span class="params">(value)</span> </span>{ 
    <span class="built_in">console</span>.log(value);
});  
</code></pre><p>  这段代码看起来更加简洁,但这种方法也有一个小缺陷:你不能使用 break 语句中 断循环,也不能使用 return 语句返回到外层函数。  </p>
</li>
<li><p>for-in 循环(千万别这样做, 是为普通对象设计的) </p>
<pre><code><span class="keyword">for</span> (<span class="reserved">var</span> index <span class="keyword">in</span> myArray) {
    <span class="built_in">console</span>.log(myArray[index]);
}
</code></pre><p>  在这段代码中,赋给index的值不是实际的数字,而是字符串“0”、“1”、“2”, 此时很可能在无意之间进行字符串算数计算,例如:“2” + 1 == “21”,这给 编码过程带来极大的不便。<br>  作用于数组的 for-in 循环体除了遍历数组元素外,还会遍历自定义属性。举个例子,如果你的数组中有一个可枚举属性 myArray.name,循环将额外执行 一次,遍历到名为“name”的索引。就连数组原型链上的属性都能被访问到。<br>  最让人震惊的是,在某些情况下,这段代码可能按照随机顺序遍历数组元素。<br>  简而言之,for-in 是为普通对象设计的,你可以遍历得到字符串类型的键,因此不适用于数组遍历。</p>
</li>
<li><p>ES6</p>
<pre><code><span class="keyword">for</span> (<span class="reserved">var</span> value <span class="keyword">of</span> myArray) {
    <span class="built_in">console</span>.log(value);
}
</code></pre><p>  for-in 循环用来遍历对象属性。<br>  for-of 循环用来遍历数据—例如数组中的值。</p>
</li>
</ul>
<h2 id="for-of_循环">for-of 循环</h2><pre><code><span class="keyword">for</span> (<span class="reserved">var</span> value <span class="keyword">of</span> myArray) {
  <span class="built_in">console</span>.log(value);
}
</code></pre><p>这是最简洁、最直接的遍历数组元素的语法<br>这个方法避开了 for-in 循环的所有缺陷<br>与 forEach()不同的是,它可以正确响应 break、continue 和 return 语句<br>for-of 循环不仅支持数组,还支持大多数类数组对象,例如 DOM NodeList 对象。<br>for-of 循环也支持字符串遍历,它将字符串视为一系列的 Unicode 字符来进行遍历  </p>
<pre><code><span class="reserved">var</span> str = <span class="string">'liuhaiming'</span>;
<span class="keyword">for</span>(<span class="reserved">var</span> chr <span class="keyword">of</span> str) {
  <span class="built_in">console</span>.log(chr);
}
</code></pre><p>for-of 循环也支持Set 对象  </p>
<pre><code>var uniqueWords = new Set(<span class="property">words</span>);
<span class="keyword">for</span> (var <span class="property">word</span> <span class="keyword">of</span> uniqueWords) {
  console.<span class="command">log</span>(<span class="property">word</span>);
}
</code></pre><p>for-of 循环也支持Map对象  </p>
<pre><code>for (<span class="built_in">var</span> [<span class="built_in">key</span>, <span class="built_in">value</span>] of phoneBookMap) {
  console.log(<span class="built_in">key</span> + <span class="string">"'s phone number is: "</span> + <span class="built_in">value</span>);
}
</code></pre><p>for-of 循环不支持普通对象,但如果你想迭代一个对象的属性,你可以用 for-in 循 环(这也是它的本职工作)或内建的 Object.keys()方法:</p>
<pre><code><span class="comment">// 向控制台输出对象的可枚举属性</span>
<span class="keyword">for</span> (var <span class="variable">key</span> of <span class="keyword">Object</span>.keys(someObject)) {
  console.<span class="built_in">log</span>(<span class="variable">key</span> + <span class="string">": "</span> + someObject[<span class="variable">key</span>]);
}
</code></pre><p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="ES6_是什么">ES6 是什么</h1><ul>
<li>编程语言 JavaScript 是 ECMAScript 的实现和扩展,由 ECMA(一个类似 W3C 的标准组织)参与进行标准化。   </li>
<li>ES4 饱受争议,当标准委员会最终停止开发 ES4 时,其成员同意发布一个相对谦和的 ES5 版本,随后继续制定一些更具实质性的新特性。这一明确的协商协议最终命 名为“Harmony”(ES6)。  </li>
<li>2009 年发布的改进版本 ES5,引入了 Object.create()、Object.defineProperty()、getters 和 setters、严格模式以及 JSON 对象。  </li>
<li>如果你想在 web 环境中使用这种新语法,同时需要支持 IE 和 Safari, 你可以使用 Babel 或 Google 的 Traceur 这些编译器来将你的 ES6 代码翻译为 Web 友好 的 ES5 代码。  </li>
</ul>]]>
    
    </summary>
    
      <category term="js" scheme="http://www.haiyue.me/tags/js/"/>
    
      <category term="笔记" scheme="http://www.haiyue.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[三亚春节]]></title>
    <link href="http://www.haiyue.me/2016/02/16/photo/sanyacunjie/"/>
    <id>http://www.haiyue.me/2016/02/16/photo/sanyacunjie/</id>
    <published>2016-02-15T16:00:00.000Z</published>
    <updated>2016-02-16T07:34:11.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7xia33.com1.z0.glb.clouddn.com/sanyaIMG_8180.jpg" alt=""><br>    在三亚过的春节，也没怎么出去玩……<br><a id="more"></a><br><img src="http://7xia33.com1.z0.glb.clouddn.com/sanyaIMG_8062.JPG" alt=""><br><img src="http://7xia33.com1.z0.glb.clouddn.com/sanyaIMG_8151.JPG" alt=""><br><img src="http://7xia33.com1.z0.glb.clouddn.com/sanyaIMG_8077.JPG" alt=""><br><img src="http://7xia33.com1.z0.glb.clouddn.com/sanyaIMG_8206.JPG" alt=""><br><img src="http://7xia33.com1.z0.glb.clouddn.com/sanyaIMG_8194.JPG" alt="">    </p>
<p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7xia33.com1.z0.glb.clouddn.com/sanyaIMG_8180.jpg" alt=""><br>    在三亚过的春节，也没怎么出去玩……<br>]]>
    
    </summary>
    
      <category term="摄影" scheme="http://www.haiyue.me/categories/%E6%91%84%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES6-Module]]></title>
    <link href="http://www.haiyue.me/2016/02/02/es6-module/"/>
    <id>http://www.haiyue.me/2016/02/02/es6-module/</id>
    <published>2016-02-01T16:00:00.000Z</published>
    <updated>2016-02-02T10:39:40.000Z</updated>
    <content type="html"><![CDATA[<p>ES6的Class只是面向对象编程的语法糖，升级了ES5的构造函数的原型链继承的写法，并没有解决模块化问题。Module功能就是为了解决这个问题而提出的。<br>在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。</p>
<pre><code>// CommonJS模块
<span class="built_in">let</span> { <span class="built_in">stat</span>, exists, <span class="built_in">read</span>File } = require(<span class="string">'fs'</span>);
</code></pre><p>上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取3个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p>
<a id="more"></a> 
<pre><code><span class="comment">// ES6模块</span>
<span class="keyword">import</span> { stat, exists, readFile } <span class="keyword">from</span> <span class="string">'fs'</span>;
</code></pre><p>上面代码的实质是从fs模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”，即ES6可以在编译时就完成模块加载，效率要比CommonJS模块的加载方式高。当然，这也导致了没法引用ES6模块本身，因为它不是对象。</p>
<h2 id="严格模式(ES5引入)">严格模式(ES5引入)</h2><p>ES6的模块自动采用严格模式，不管你有没有在模块头部加上”use strict”。</p>
<h2 id="export命令">export命令</h2><p>模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。<br>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。</p>
<pre><code><span class="comment">// good</span>
<span class="literal">export</span> <span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;
<span class="literal">export</span> <span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;
<span class="comment">// best</span>
<span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;
<span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;
<span class="literal">export</span> {firstName, lastName};
</code></pre><p>export命令除了输出变量，还可以输出函数或类（class）。</p>
<pre><code><span class="keyword">function</span> v1() { <span class="keyword">...</span> }
<span class="keyword">function</span> v2() { <span class="keyword">...</span> }
export {
  v1 as streamV1,
  v2 as streamV2,
  v2 as streamLatestVersion
};
</code></pre><p>export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下面的import命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。<br>export语句输出的值是动态绑定，绑定其所在的模块。</p>
<pre><code><span class="reserved">export</span> <span class="reserved">var</span> foo = <span class="string">'bar'</span>;
setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> foo = <span class="string">'baz'</span>, <span class="number">500</span>);
</code></pre><p>上面代码输出变量foo，值为bar，500毫秒之后变成baz。</p>
<h2 id="import命令">import命令</h2><p>使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）。</p>
<pre><code><span class="keyword">import</span> {firstName, lastName, year} <span class="keyword">from</span> <span class="string">'./profile'</span>;
</code></pre><p>import命令接受一个对象（用大括号表示），里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。<br>如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。</p>
<pre><code><span class="keyword">import</span> { lastName <span class="keyword">as</span> surname } <span class="keyword">from</span> <span class="string">'./profile'</span>;
</code></pre><p>import命令具有提升效果，会提升到整个模块的头部，首先执行。</p>
<pre><code>foo();
<span class="keyword">import</span> { foo } <span class="keyword">from</span> <span class="string">'my_module'</span>;
</code></pre><p>如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。</p>
<pre><code><span class="literal">export</span> { es6 <span class="literal">as</span> <span class="keyword">default</span> } from <span class="string">'./someModule'</span>;
<span class="comment">// 等同于 (best)</span>
<span class="literal">import</span> { es6 } from <span class="string">'./someModule'</span>;
<span class="literal">export</span> <span class="keyword">default</span> es6;
</code></pre><h2 id="模块的整体加载">模块的整体加载</h2><p>除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。</p>
<pre><code><span class="keyword">import</span> * as circle <span class="keyword">from</span> <span class="string">'./circle'</span>;
<span class="built_in">console</span>.log(<span class="string">"圆面积："</span> <span class="string">\+</span> circle.area(<span class="number">4</span>));
<span class="built_in">console</span>.log(<span class="string">"圆周长："</span> <span class="string">\+</span> circle.circumference(<span class="number">14</span>));
</code></pre><h3 id="export_default命令">export default命令</h3><p>export default命令，为模块指定默认输出。一个模块只能有一个默认输出，因此export deault命令只能使用一次。</p>
<pre><code>export <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);
}
</code></pre><p>其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。这时import命令后面，不使用大括号。</p>
<pre><code><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">'./export-default'</span>;
customName(); <span class="comment">// 'foo'</span>
</code></pre><p>export default命令用在非匿名函数前，也是可以的。加载的时候，视同匿名函数加载。<br>如果想在一条import语句中，同时输入默认方法和其他变量，可以写成下面这样。  </p>
<pre><code><span class="keyword">import</span> customName, { otherMethod } <span class="keyword">from</span> <span class="string">'./export-default'</span>;
</code></pre><h2 id="模块的继承">模块的继承</h2><pre><code><span class="keyword">export</span> * from <span class="string">'circle'</span>;
<span class="keyword">export</span> <span class="keyword">var</span> e = <span class="number">2.71828182846</span>;
<span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span><span class="params">(x)</span> </span>{
  <span class="keyword">return</span> <span class="built_in">Math</span>.exp(x);
}
</code></pre><p>上面代码中的export <em>，表示再输出circle模块的所有属性和方法。注意，export </em>命令会忽略circle模块的default方法。然后，上面代码又输出了自定义的e变量和默认方法。</p>
<h2 id="ES6模块加载的实质">ES6模块加载的实质</h2><p>ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，一旦输出一个值，模块内部的变化就影响不到这个值。而ES6模块输出的是值的引,用此，ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。。<br>由于ES6输入的模块变量，只是一个”符号连接“，所以这个变量是只读的，对它进行重新赋值会报错。</p>
<h2 id="ES6模块的循环加载">ES6模块的循环加载</h2><p>ES6处理“循环加载”与CommonJS有本质的不同。ES6模块是动态引用，遇到模块加载命令import时，不会去执行模块，只是生成一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</p>
<h2 id="ES6模块的转码">ES6模块的转码</h2><p>浏览器目前还不支持ES6模块，为了现在就能使用，可以将转为ES5的写法。除了Babel可以用来转码之外，还有以下两个方法，也可以用来转码。</p>
<pre><code><span class="constant">ES6</span> <span class="class"><span class="keyword">module</span> <span class="title">transpiler</span></span>
<span class="constant">SystemJS</span>
</code></pre><p>读阮一峰老师《ECMAScript6入门》一书的笔记<br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>ES6的Class只是面向对象编程的语法糖，升级了ES5的构造函数的原型链继承的写法，并没有解决模块化问题。Module功能就是为了解决这个问题而提出的。<br>在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。</p>
<pre><code>// CommonJS模块
<span class="built_in">let</span> { <span class="built_in">stat</span>, exists, <span class="built_in">read</span>File } = require(<span class="string">'fs'</span>);
</code></pre><p>上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取3个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</p>]]>
    
    </summary>
    
      <category term="ECMAScript6入门" scheme="http://www.haiyue.me/tags/ECMAScript6%E5%85%A5%E9%97%A8/"/>
    
      <category term="笔记" scheme="http://www.haiyue.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES6-Class基本语法]]></title>
    <link href="http://www.haiyue.me/2016/02/02/es6-class/"/>
    <id>http://www.haiyue.me/2016/02/02/es6-class/</id>
    <published>2016-02-01T16:00:00.000Z</published>
    <updated>2016-02-02T10:37:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Class基本语法">Class基本语法</h2><p>ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p>
<pre><code><span class="comment">// old</span>
  <span class="function"><span class="keyword">function</span> <span class="title">Point</span><span class="params">(x,y)</span></span>{
  <span class="keyword">this</span>.x = x;
  <span class="keyword">this</span>.y = y;
}
Point.prototype.toString = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;
}
<span class="comment">// new</span>
<span class="keyword">class</span> Point {
  <span class="constructor"><span class="keyword">constructor</span>(x, y) </span>{
    <span class="keyword">this</span>.x = x;
    <span class="keyword">this</span>.y = y;
  }
  toString() {
    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;
  }   
}
</code></pre><a id="more"></a> 
<p>Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个保留字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。<br>构造函数的prototype属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。<br>类的内部所有定义的方法，都是不可枚举的（enumerable）。这一点与ES5的行为不一致。</p>
<pre><code><span class="keyword">class</span> Point {
  <span class="constructor"><span class="keyword">constructor</span>(x, y) </span>{}
  toString() {}
}
<span class="built_in">Object</span>.keys(Point.prototype) <span class="comment">// []</span>
<span class="built_in">Object</span>.getOwnPropertyNames(Point.prototype) <span class="comment">// ["constructor","toString"]</span>
</code></pre><p>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。<br>constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</p>
<pre><code><span class="keyword">class</span> Foo {
  <span class="constructor"><span class="keyword">constructor</span>() </span>{
    <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);
  }
}
<span class="keyword">new</span> Foo() <span class="keyword">instanceof</span> Foo; <span class="comment">// false </span>
</code></pre><p>生成实例对象的写法，与ES5完全一样，也是使用new命令。如果忘记加上new，像函数那样调用Class，将会报错。<br>与ES5一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）<br>与ES5一样，类的所有实例共享一个原型对象。所以<strong>proto</strong>属性是相等的。<br>name属性总是返回紧跟在class关键字后面的类名。</p>
<pre><code>class <span class="keyword">Point</span> <span class="list">{}</span>
<span class="keyword">Point</span>.name // <span class="string">"Point"</span>
</code></pre><p>下面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在Class的内部代码可用，指代当前类。</p>
<pre><code><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>{
  getClassName() {
    <span class="keyword">return</span> Me.name;
  }
};
</code></pre><p>如果Class内部没用到的话，可以省略Me。<br>采用Class表达式，可以写出立即执行的Class。<br>Class不存在变量提升（hoist），这一点与ES5完全不同。</p>
<pre><code><span class="keyword">new</span> Foo(); <span class="comment">// ReferenceError</span>
<span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>{}
</code></pre><p>类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。<br>考虑到未来所有的代码，其实都是运行在模块之中，所以ES6实际上把整个语言升级到了严格模式。</p>
<h2 id="Class的继承">Class的继承</h2><p>Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Point</span> {</span>}
</code></pre><p>下面代码中，constructor方法和toString方法之中，都出现了super关键字，它指代父类的实例（即父类的this对象）。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Point</span> {</span>
  constructor(x, y, color) {
    <span class="keyword">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span>
    <span class="keyword">this</span>.color = color;
  }
  toString() {
    <span class="keyword">return</span> <span class="keyword">this</span>.color + ' ' + <span class="keyword">super</span>.toString(); <span class="comment">// 调用父类的toString()</span>
  }
}
</code></pre><p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。<br>子类实例的<strong>proto</strong>属性的<strong>proto</strong>属性，指向父类实例的<strong>proto</strong>属性。也就是说，子类的原型的原型，是父类的原型。</p>
<h2 id="原生构造函数的继承">原生构造函数的继承</h2><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构。<br>ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Array</span> {</span>
  constructor(...args) {
    <span class="keyword">super</span>(...args);
  }
}
<span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="type">MyArray</span>();
arr[<span class="number">0</span>] = <span class="number">12</span>;
arr.length <span class="comment">// 1</span>
arr.length = <span class="number">0</span>;
arr[<span class="number">0</span>] <span class="comment">// undefined</span>
</code></pre><h2 id="Class的取值函数（getter）和存值函数（setter）">Class的取值函数（getter）和存值函数（setter）</h2><p>与ES5一样，在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<pre><code><span class="keyword">class</span> MyClass {
  <span class="constructor"><span class="keyword">constructor</span>() </span>{
    <span class="comment">// ...</span>
  }
  <span class="keyword">get</span> prop() {
    <span class="keyword">return</span> <span class="string">'getter'</span>;
  }
  <span class="keyword">set</span> prop(value) {
    <span class="built_in">console</span>.log(<span class="string">'setter: '</span>+value);
  }
}
<span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();
inst.prop = <span class="number">123</span>; <span class="comment">// setter: 123</span>
inst.prop <span class="comment">// 'getter'</span>
</code></pre><h2 id="Class的静态方法">Class的静态方法</h2><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<pre><code><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> {</span>
  static classMethod() {
    <span class="keyword">return</span> <span class="string">'hello'</span>;
  }
}
Foo.classMethod() <span class="regexp">//</span> <span class="string">'hello'</span>
<span class="reserved">var</span> foo = <span class="keyword">new</span> Foo();
foo.classMethod() <span class="regexp">//</span> <span class="attribute">TypeError</span>: <span class="literal">undefined</span> <span class="keyword">is</span> <span class="keyword">not</span> a <span class="reserved">function</span>
</code></pre><p>父类的静态方法，可以被子类继承。<br>静态方法也是可以从super对象上调用的。</p>
<h2 id="Class的静态属性">Class的静态属性</h2><p>静态属性指的是Class本身的属性，即Class.propname，而不是定义在实例对象（this）上的属性。</p>
<pre><code><span class="keyword">class</span> Foo {
}
Foo.<span class="keyword">prop</span> = 1;
Foo.<span class="keyword">prop</span> <span class="comment">// 1</span>
</code></pre><p>目前，只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。</p>
<h2 id="new-target属性">new.target属性</h2><p>new是从构造函数生成实例的命令。ES6为new命令引入了一个new.target属性，（在构造函数中）返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name)</span> </span>{
  <span class="keyword">if</span> (<span class="keyword">new</span>.target !== <span class="literal">undefined</span>) {
    <span class="keyword">this</span>.name = name;
  } <span class="keyword">else</span> {
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必须使用new生成实例'</span>);
  }
}
<span class="comment">// 另一种写法</span>
<span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name)</span> </span>{
  <span class="keyword">if</span> (<span class="keyword">new</span>.target === Person) {
    <span class="keyword">this</span>.name = name;
  } <span class="keyword">else</span> {
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必须使用new生成实例'</span>);
  }
}
<span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'张三'</span>); <span class="comment">// 正确</span>
<span class="keyword">var</span> notAPerson = Person.call(person, <span class="string">'张三'</span>); <span class="comment">// 报错</span>
</code></pre><p>Class内部调用new.target，返回当前Class。<br>子类继承父类时，new.target会返回子类。</p>
<pre><code><span class="keyword">class</span> Rectangle {
  <span class="constructor"><span class="keyword">constructor</span>(length, width) </span>{
    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);
    <span class="comment">// ...</span>
  }
}
<span class="keyword">class</span> Square extends Rectangle {
  <span class="constructor"><span class="keyword">constructor</span>(length) </span>{
    <span class="keyword">super</span>(length, length);
  }
}
<span class="keyword">var</span> obj = <span class="keyword">new</span> Square(<span class="number">3</span>); <span class="comment">// 输出 false</span>
</code></pre><p>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</p>
<h2 id="类的修饰">类的修饰</h2><p>修饰器（Decorator）是一个表达式，用来修改类的行为。这是ES7的一个提案，目前Babel转码器已经支持。<br>修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。  </p>
<p>读阮一峰老师《ECMAScript6入门》一书的笔记<br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Class基本语法">Class基本语法</h2><p>ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p>
<pre><code><span class="comment">// old</span>
  <span class="function"><span class="keyword">function</span> <span class="title">Point</span><span class="params">(x,y)</span></span>{
  <span class="keyword">this</span>.x = x;
  <span class="keyword">this</span>.y = y;
}
Point.prototype.toString = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>{
  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;
}
<span class="comment">// new</span>
<span class="keyword">class</span> Point {
  <span class="constructor"><span class="keyword">constructor</span>(x, y) </span>{
    <span class="keyword">this</span>.x = x;
    <span class="keyword">this</span>.y = y;
  }
  toString() {
    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;
  }   
}
</code></pre>]]>
    
    </summary>
    
      <category term="ECMAScript6入门" scheme="http://www.haiyue.me/tags/ECMAScript6%E5%85%A5%E9%97%A8/"/>
    
      <category term="笔记" scheme="http://www.haiyue.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES6-Module]]></title>
    <link href="http://www.haiyue.me/2016/02/02/es6-style/"/>
    <id>http://www.haiyue.me/2016/02/02/es6-style/</id>
    <published>2016-02-01T16:00:00.000Z</published>
    <updated>2016-02-02T10:41:12.000Z</updated>
    <content type="html"><![CDATA[<h1 id="规格文件">规格文件</h1><p>规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。<br>ECMAScript 6的规格，可以在ECMA国际标准组织的官方网站（www.ecma-international.org/ecma-262/6.0/）免费下载和在线阅读。</p>
<a id="more"></a> 
<h1 id="编程风格">编程风格</h1><h2 id="块级作用域">块级作用域</h2><p>let取代var<br>全局常量和线程安全<br>在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。这符合函数式编程思想，有利于将来的分布式运算。</p>
<pre><code><span class="comment">// bad</span>
<span class="keyword">var</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c = <span class="number">3</span>;
<span class="comment">// good</span>
<span class="keyword">const</span> a = <span class="number">1</span>;
<span class="keyword">const</span> b = <span class="number">2</span>;
<span class="keyword">const</span> c = <span class="number">3</span>;
</code></pre><p>const声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。<br>所有的函数都应该设置为常量。</p>
<h2 id="严格模式">严格模式</h2><p>V8引擎只在严格模式之下，支持let。  </p>
<h2 id="字符串">字符串</h2><p>静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。</p>
<pre><code><span class="comment">// bad</span>
<span class="keyword">const</span> a = <span class="string">"foobar"</span>;
<span class="keyword">const</span> b = <span class="string">'foo'</span> + a + <span class="string">'bar'</span>;
<span class="comment">// good</span>
<span class="keyword">const</span> a = <span class="string">'foobar'</span>;
<span class="keyword">const</span> b = <span class="string">`foo${a}bar`</span>;
</code></pre><h2 id="解构赋值">解构赋值</h2><p>使用数组成员对变量赋值时，优先使用解构赋值。</p>
<pre><code><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];
<span class="comment">// bad</span>
<span class="keyword">const</span> first = arr[<span class="number">0</span>];
<span class="keyword">const</span> <span class="built_in">second</span> = arr[<span class="number">1</span>];
<span class="comment">// good</span>
<span class="keyword">const</span> [first, <span class="built_in">second</span>] = arr;
</code></pre><p>函数的参数如果是对象的成员，优先使用解构赋值。</p>
<pre><code><span class="comment">// bad</span>
<span class="function"><span class="keyword">function</span> <span class="title">getFullName</span><span class="params">(user)</span> </span>{
  <span class="keyword">const</span> firstName = user.firstName;
  <span class="keyword">const</span> lastName = user.lastName;
}
<span class="comment">// best</span>
<span class="function"><span class="keyword">function</span> <span class="title">getFullName</span><span class="params">({ firstName, lastName })</span> </span>{
}
</code></pre><p>如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。</p>
<pre><code><span class="comment">// bad</span>
<span class="function"><span class="keyword">function</span> <span class="title">processInput</span><span class="params">(input)</span> </span>{
  <span class="keyword">return</span> [left, right, top, bottom];
}
<span class="comment">// good</span>
<span class="function"><span class="keyword">function</span> <span class="title">processInput</span><span class="params">(input)</span> </span>{
  <span class="keyword">return</span> { left, right, top, bottom };
}
<span class="keyword">const</span> { left, right } = processInput(input);
</code></pre><h2 id="数组">数组</h2><p>使用扩展运算符（…）拷贝数组。</p>
<pre><code><span class="comment">// bad</span>
<span class="keyword">const</span> <span class="built_in">len</span> = items.length;
<span class="keyword">const</span> itemsCopy = [];
<span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; <span class="built_in">len</span>; i++) {
  itemsCopy[i] = items[i];
}
<span class="comment">// good</span>
<span class="keyword">const</span> itemsCopy = [...items];
</code></pre><p>使用Array.from方法，将类似数组的对象转为数组。</p>
<pre><code><span class="keyword">const</span> foo = <span class="built_in">document</span>.<span class="built_in">querySelectorAll</span>(<span class="string">'.foo'</span>);
<span class="keyword">const</span> nodes = Array.from(foo);
</code></pre><p>立即执行函数可以写成箭头函数的形式。</p>
<pre><code><span class="list">(<span class="list">()</span> =&gt; <span class="collection">{
  console.log<span class="list">(<span class="keyword">'Welcome</span> to the Internet.')</span><span class="comment">;</span>
}</span>)</span><span class="list">()</span><span class="comment">;</span>
</code></pre><p>那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了this。</p>
<pre><code><span class="comment">// bad</span>
[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> <span class="params">(x)</span> </span>{
  <span class="keyword">return</span> x * x;
});
<span class="comment">// best</span>
[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(x =&gt; x * x);
</code></pre><p>简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。  </p>
<p>不要在函数体内使用arguments变量，使用rest运算符（…）代替。因为rest运算符显式表明你想要获取参数，而且arguments是一个类似数组的对象，而rest运算符可以提供一个真正的数组。</p>
<pre><code><span class="comment">// bad</span>
<span class="function"><span class="keyword">function</span> <span class="title">concatenateAll</span><span class="params">()</span> </span>{
  <span class="keyword">const</span> args = Array.prototype.slice.call(arguments);
  <span class="keyword">return</span> args.join(<span class="string">''</span>);
}
<span class="comment">// good</span>
<span class="function"><span class="keyword">function</span> <span class="title">concatenateAll</span><span class="params">(<span class="rest_arg">...args</span>)</span> </span>{
  <span class="keyword">return</span> args.join(<span class="string">''</span>);
}
</code></pre><p>使用默认值语法设置函数参数的默认值。</p>
<pre><code>// bad
<span class="keyword">function</span> handleThings(opts) {
  opts = opts || {};
}
// good
<span class="keyword">function</span> handleThings(opts = {}) {
  // <span class="keyword">...</span>
}
</code></pre><p>所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。</p>
<pre><code><span class="comment">// bad</span>
<span class="function"><span class="keyword">function</span> <span class="title">divide</span><span class="params">(a, b, option = false )</span> </span>{
}
<span class="comment">// good</span>
<span class="function"><span class="keyword">function</span> <span class="title">divide</span><span class="params">(a, b, { option = false } = {})</span> </span>{
}
</code></pre><h2 id="Map结构">Map结构</h2><p>注意区分Object和Map，只有模拟实体对象时，才使用Object。如果只是需要key: value的数据结构，使用Map结构。因为Map有内建的遍历机制。</p>
<pre><code><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="type">Map</span>(arr);
<span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys<span class="literal">()</span>) {
  console.log(key);
}
<span class="keyword">for</span> (<span class="keyword">let</span> <span class="keyword">value</span> <span class="keyword">of</span> map.values<span class="literal">()</span>) {
  console.log(<span class="keyword">value</span>);
}
<span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.entries<span class="literal">()</span>) {
  console.log(item[<span class="number">0</span>], item[<span class="number">1</span>]);
}
</code></pre><h2 id="Class">Class</h2><p>总是用Class，取代需要prototype的操作。因为Class的写法更简洁，更易于理解。</p>
<pre><code><span class="comment">// bad</span>
<span class="function"><span class="keyword">function</span> <span class="title">Queue</span><span class="params">(contents = [])</span> </span>{
  <span class="keyword">this</span>._queue = [...contents];
}
Queue.prototype.pop = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="keyword">const</span> value = <span class="keyword">this</span>._queue[<span class="number">0</span>];
  <span class="keyword">this</span>._queue.splice(<span class="number">0</span>, <span class="number">1</span>);
  <span class="keyword">return</span> value;
}
<span class="comment">// good</span>
<span class="keyword">class</span> Queue {
  <span class="constructor"><span class="keyword">constructor</span>(contents = []) </span>{
    <span class="keyword">this</span>._queue = [...contents];
  }
  pop() {
    <span class="keyword">const</span> value = <span class="keyword">this</span>._queue[<span class="number">0</span>];
    <span class="keyword">this</span>._queue.splice(<span class="number">0</span>, <span class="number">1</span>);
    <span class="keyword">return</span> value;
  }
}
</code></pre><p>使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。</p>
<pre><code><span class="comment">// bad</span>
const inherits = require(<span class="symbol">'inherit</span>s');
function <span class="type">PeekableQueue</span>(contents) {
  <span class="type">Queue</span>.apply(<span class="keyword">this</span>, contents);
}
inherits(<span class="type">PeekableQueue</span>, <span class="type">Queue</span>);
<span class="type">PeekableQueue</span>.prototype.peek = function() {
  <span class="keyword">return</span> <span class="keyword">this</span>._queue[<span class="number">0</span>];
}
<span class="comment">// good</span>
<span class="class"><span class="keyword">class</span> <span class="title">PeekableQueue</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Queue</span> {</span>
  peek() {
    <span class="keyword">return</span> <span class="keyword">this</span>._queue[<span class="number">0</span>];
  }
}
</code></pre><h2 id="模块">模块</h2><p>Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用import取代require。</p>
<pre><code><span class="comment">// bad</span>
<span class="keyword">const</span> moduleA = <span class="keyword">require</span>(<span class="string">'moduleA'</span>);
<span class="keyword">const</span> func1 = moduleA.func1;
<span class="keyword">const</span> func2 = moduleA.func2;
<span class="comment">// good</span>
import <span class="comment">{ func1, func2 }</span> <span class="keyword">from</span> <span class="string">'moduleA'</span>;
</code></pre><p>使用export取代module.exports。<br>如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，不要export default与普通的export同时使用。</p>
<pre><code><span class="regexp">//</span> commonJS的写法
<span class="reserved">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>);
<span class="reserved">var</span> Breadcrumbs = React.createClass({
  render() {
    <span class="keyword">return</span> &lt;nav /&gt;;
  }
});
<span class="built_in">module</span>.exports = Breadcrumbs;
<span class="regexp">//</span> ES6的写法
<span class="reserved">import</span> React from <span class="string">'react'</span>;
<span class="reserved">const</span> Breadcrumbs = React.createClass({
  render() {
    <span class="keyword">return</span> &lt;nav /&gt;;
  }
});
<span class="reserved">export</span> <span class="reserved">default</span> Breadcrumbs
</code></pre><p>如果模块默认输出一个函数，函数名的首字母应该小写。</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">makeStyleGuide</span><span class="params">()</span> </span>{
}
export <span class="keyword">default</span> makeStyleGuide;
</code></pre><p>如果模块默认输出一个对象，对象名的首字母应该大写。</p>
<pre><code><span class="reserved">const</span> StyleGuide = {
  <span class="attribute">es6</span>: {
  }
};
<span class="reserved">export</span> <span class="reserved">default</span> StyleGuide;
</code></pre><p>读阮一峰老师《ECMAScript6入门》一书的笔记<br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="规格文件">规格文件</h1><p>规格文件是计算机语言的官方标准，详细描述语法规则和实现方法。<br>ECMAScript 6的规格，可以在ECMA国际标准组织的官方网站（www.ecma-international.org/ecma-262/6.0/）免费下载和在线阅读。</p>]]>
    
    </summary>
    
      <category term="ECMAScript6入门" scheme="http://www.haiyue.me/tags/ECMAScript6%E5%85%A5%E9%97%A8/"/>
    
      <category term="笔记" scheme="http://www.haiyue.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[北京大雪]]></title>
    <link href="http://www.haiyue.me/2016/01/06/photo/beijingdaxue/"/>
    <id>http://www.haiyue.me/2016/01/06/photo/beijingdaxue/</id>
    <published>2016-01-05T16:00:00.000Z</published>
    <updated>2016-02-01T10:25:01.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7xia33.com1.z0.glb.clouddn.com/bjdaxIMG_733823232.jpg" alt=""><br>    北京难得一见的大雪，冰天雪地的很好看。<br><a id="more"></a><br><img src="http://7xia33.com1.z0.glb.clouddn.com/bjdaxIMG_7408.JPG" alt=""><br><img src="http://7xia33.com1.z0.glb.clouddn.com/bjdaxIMG_7307.JPG" alt=""><br><img src="http://7xia33.com1.z0.glb.clouddn.com/bjdaxIMG_7326.JPG" alt=""><br><img src="http://7xia33.com1.z0.glb.clouddn.com/bjdaxIMG_7331.JPG" alt=""><br><img src="http://7xia33.com1.z0.glb.clouddn.com/bjdaxIMG_7351.JPG" alt=""><br><img src="http://7xia33.com1.z0.glb.clouddn.com/bjdaxIMG_7392.JPG" alt=""><br><img src="http://7xia33.com1.z0.glb.clouddn.com/bjdaxIMG_7395.JPG" alt=""><br><img src="http://7xia33.com1.z0.glb.clouddn.com/bjdaxIMG_7415.JPG" alt=""><br><img src="http://7xia33.com1.z0.glb.clouddn.com/bjdaxIMG_7424.JPG" alt="">  </p>
<p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7xia33.com1.z0.glb.clouddn.com/bjdaxIMG_733823232.jpg" alt=""><br>    北京难得一见的大雪，冰天雪地的很好看。<br>]]>
    
    </summary>
    
      <category term="摄影" scheme="http://www.haiyue.me/categories/%E6%91%84%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[蓝色港湾跨年夜]]></title>
    <link href="http://www.haiyue.me/2016/01/06/photo/lansegangwan/"/>
    <id>http://www.haiyue.me/2016/01/06/photo/lansegangwan/</id>
    <published>2016-01-05T16:00:00.000Z</published>
    <updated>2016-02-01T10:18:33.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7xia33.com1.z0.glb.clouddn.com/lsgwIMG_75423232.jpg" alt=""><br>    跨年夜无聊去蓝色港湾看灯展，还是挺好看的。<br><a id="more"></a><br><img src="http://7xia33.com1.z0.glb.clouddn.com/lsgwIMG_7560.JPG" alt=""><br><img src="http://7xia33.com1.z0.glb.clouddn.com/lsgwIMG_7515.JPG" alt=""><br><img src="http://7xia33.com1.z0.glb.clouddn.com/lsgwIMG_7461.JPG" alt=""><br><img src="http://7xia33.com1.z0.glb.clouddn.com/lsgwIMG_7466.JPG" alt=""><br><img src="http://7xia33.com1.z0.glb.clouddn.com/lsgwIMG_7610.JPG" alt=""><br><img src="http://7xia33.com1.z0.glb.clouddn.com/lsgwIMG_7616.JPG" alt="">  </p>
<p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7xia33.com1.z0.glb.clouddn.com/lsgwIMG_75423232.jpg" alt=""><br>    跨年夜无聊去蓝色港湾看灯展，还是挺好看的。<br>]]>
    
    </summary>
    
      <category term="摄影" scheme="http://www.haiyue.me/categories/%E6%91%84%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES6-Generator函数]]></title>
    <link href="http://www.haiyue.me/2015/10/28/es6-generator/"/>
    <id>http://www.haiyue.me/2015/10/28/es6-generator/</id>
    <published>2015-10-27T16:00:00.000Z</published>
    <updated>2016-02-02T04:12:17.000Z</updated>
    <content type="html"><![CDATA[<h2 id="基本概念">基本概念</h2><p>Generator函数是ES6提供的一种异步编程解决方案<br>Generator函数有两个特征。一是，function命令与函数名之间有一个星号；二是，函数体内部使用yield语句，定义不同的内部状态。<br>调用Generator函数后，该函数并不执行，返回的是一个指向内部状态的指针对象（遍历器对象）。下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield语句（或return语句）为止。  </p>
<pre><code><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span><span class="params">()</span></span> {
  yield <span class="string">'hello'</span>;
  yield <span class="string">'world'</span>;
  <span class="keyword">return</span> <span class="string">'ending'</span>;
}
var hw = helloWorldGenerator();
hw.<span class="built_in">next</span>() // { value: <span class="string">'hello'</span>, done: <span class="keyword">false</span> }
hw.<span class="built_in">next</span>() // { value: <span class="string">'world'</span>, done: <span class="keyword">false</span> }
hw.<span class="built_in">next</span>() // { value: <span class="string">'ending'</span>, done: <span class="keyword">true</span> }
hw.<span class="built_in">next</span>() // { value: undefined, done: <span class="keyword">true</span> }
</code></pre><p>每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield语句后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。</p>
<a id="more"></a> 
<h2 id="yield语句">yield语句</h2><p>遍历器对象的next方法的运行逻辑如下。</p>
<pre><code>遇到<span class="keyword">yield</span>语句，就暂停执行后面的操作，并将紧跟在<span class="keyword">yield</span>后面的那个表达式的值，作为返回的对象的<span class="keyword">value</span>属性值。
下一次调用next方法时，再继续往下执行，直到遇到下一个<span class="keyword">yield</span>语句。
如果没有再遇到新的<span class="keyword">yield</span>语句，就一直运行到函数结束，直到<span class="keyword">return</span>语句为止，并将<span class="keyword">return</span>语句后面的表达式的值，作为返回的对象的<span class="keyword">value</span>属性值。
如果该函数没有<span class="keyword">return</span>语句，则返回的对象的<span class="keyword">value</span>属性值为undefined。
</code></pre><p>yield语句后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为JavaScript提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。<br>一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield语句。<br>yield语句不能用在普通函数中，否则会报错。<br>yield语句如果用在一个表达式之中，必须放在圆括号里面。yield语句用作函数参数或赋值表达式的右边，可以不加括号。</p>
<h2 id="next方法的参数">next方法的参数</h2><p>yield句本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值。<br>由于next方法的参数表示上一个yield语句的返回值，所以第一次使用next方法时，不能带有参数。V8引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。</p>
<h2 id="for…of循环">for…of循环</h2><p>for…of循环可以自动遍历Generator函数，且此时不再需要调用next方法。这里需要注意，一旦next方法的返回对象的done属性为true，for…of循环就会中止，且不包含该返回对象。<br>for…of循环、扩展运算符（…）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，它们可以将Generator函数返回的Iterator对象，作为参数。</p>
<pre><code><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span> <span class="params">()</span> </span>{
  <span class="keyword">yield</span> <span class="number">1</span>
  <span class="keyword">yield</span> <span class="number">2</span>
  <span class="keyword">return</span> <span class="number">3</span>
  <span class="keyword">yield</span> <span class="number">4</span>
}
[...numbers()] <span class="comment">// [1, 2]</span>
<span class="built_in">Array</span>.from(numbers()) <span class="comment">// [1, 2]</span>
<span class="keyword">let</span> [x, y] = numbers();
x <span class="comment">// 1</span>
y <span class="comment">// 2</span>
<span class="keyword">for</span> (<span class="keyword">let</span> n of numbers()) {
  <span class="built_in">console</span>.log(n)
}
<span class="comment">// 1</span>
<span class="comment">// 2</span>
</code></pre><h2 id="Generator-prototype-throw()">Generator.prototype.throw()</h2><p>Generator函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在Generator函数体内捕获。<br>如果Generator函数内部没有部署try…catch代码块，那么throw方法抛出的错误，将被外部try…catch代码块捕获。<br>如果Generator函数内部部署了try…catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历，否则遍历直接终止。<br>Generator函数内抛出的错误，也可以被函数体外的catch捕获。</p>
<h2 id="Generator-prototype-return()">Generator.prototype.return()</h2><p>Generator函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。</p>
<pre><code><span class="function"><span class="keyword">function</span>* <span class="title">gen</span><span class="params">()</span> </span>{
  <span class="keyword">yield</span> <span class="number">1</span>;
  <span class="keyword">yield</span> <span class="number">2</span>;
  <span class="keyword">yield</span> <span class="number">3</span>;
}
<span class="keyword">var</span> g = gen();
g.next()        <span class="comment">// { value: 1, done: false }</span>
g.<span class="keyword">return</span>(<span class="string">"foo"</span>) <span class="comment">// { value: "foo", done: true }</span>
g.next()        <span class="comment">// { value: undefined, done: true }</span>
</code></pre><p>如果return方法调用时，不提供参数，则返回值的vaule属性为undefined。<br>如果Generator函数内部有try…finally代码块，那么return方法会推迟到finally代码块执行完再执行。</p>
<h2 id="yield*语句">yield*语句</h2><p>yield<em>语句，用来在一个Generator函数里面执行另一个Generator函数。<br>yield</em>语句等同于在Generator函数内部，部署一个for…of循环。<br>如果yield*后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。</p>
<pre><code><span class="function"><span class="keyword">function</span>* <span class="title">gen</span><span class="params">()</span></span>{    
  <span class="keyword">yield</span>* [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];
}
gen().next() <span class="comment">// { value:"a", done:false }</span>
</code></pre><h2 id="作为对象属性的Generator函数">作为对象属性的Generator函数</h2><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">obj =</span> &#123;</span><br><span class="line">  * myGeneratorMethod() &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  myGeneratorMethod: <span class="function"><span class="keyword">function</span>* <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="构造函数是Generator函数_//_？">构造函数是Generator函数 // ？</h2><h2 id="Generator函数推导_//_?">Generator函数推导 // ?</h2><h2 id="Generator与状态机_//_?">Generator与状态机 // ?</h2><h2 id="Generator与协程_//_?">Generator与协程 // ?</h2><h2 id="异步操作的同步化表达">异步操作的同步化表达</h2><p>Generator函数的暂停执行的效果，意味着可以把异步操作写在yield语句里面，等到调用next方法时再往后执行。</p>
<pre><code>function* main() {
  <span class="keyword">var</span> <span class="literal">result</span> = <span class="keyword">yield</span> request(<span class="string">"http://some.url"</span>);
  <span class="keyword">var</span> resp = <span class="type">JSON</span>.parse(<span class="literal">result</span>);
    console.log(resp.value);
}
function request(url) {
  makeAjaxCall(url, function(response){
    it.next(response);
  });
}
<span class="keyword">var</span> it = main();
it.next();
</code></pre><h2 id="控制流管理_//_???">控制流管理 // ???</h2><h2 id="部署iterator接口_//_?">部署iterator接口 // ?</h2><h2 id="作为数据结构_//_?">作为数据结构 // ?</h2><p>读阮一峰老师《ECMAScript6入门》一书的笔记<br><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="基本概念">基本概念</h2><p>Generator函数是ES6提供的一种异步编程解决方案<br>Generator函数有两个特征。一是，function命令与函数名之间有一个星号；二是，函数体内部使用yield语句，定义不同的内部状态。<br>调用Generator函数后，该函数并不执行，返回的是一个指向内部状态的指针对象（遍历器对象）。下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield语句（或return语句）为止。  </p>
<pre><code><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span><span class="params">()</span></span> {
  yield <span class="string">'hello'</span>;
  yield <span class="string">'world'</span>;
  <span class="keyword">return</span> <span class="string">'ending'</span>;
}
var hw = helloWorldGenerator();
hw.<span class="built_in">next</span>() // { value: <span class="string">'hello'</span>, done: <span class="keyword">false</span> }
hw.<span class="built_in">next</span>() // { value: <span class="string">'world'</span>, done: <span class="keyword">false</span> }
hw.<span class="built_in">next</span>() // { value: <span class="string">'ending'</span>, done: <span class="keyword">true</span> }
hw.<span class="built_in">next</span>() // { value: undefined, done: <span class="keyword">true</span> }
</code></pre><p>每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield语句后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。</p>]]>
    
    </summary>
    
      <category term="ECMAScript6入门" scheme="http://www.haiyue.me/tags/ECMAScript6%E5%85%A5%E9%97%A8/"/>
    
      <category term="笔记" scheme="http://www.haiyue.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[香山红叶节]]></title>
    <link href="http://www.haiyue.me/2015/10/28/photo/xiangshan/"/>
    <id>http://www.haiyue.me/2015/10/28/photo/xiangshan/</id>
    <published>2015-10-27T16:00:00.000Z</published>
    <updated>2016-02-01T10:22:39.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7xia33.com1.z0.glb.clouddn.com/IMG_70742324.jpg" alt=""><br>老早爬起来去香山看红叶，没有想象中的那么好，红叶不多，可能去的还不是时候。<br><a id="more"></a><br><img src="http://7xia33.com1.z0.glb.clouddn.com/xiangshanIMG_6998.JPG" alt=""><br><img src="http://7xia33.com1.z0.glb.clouddn.com/xiangshanIMG_7008.JPG" alt=""><br><img src="http://7xia33.com1.z0.glb.clouddn.com/xiangshanIMG_7035.JPG" alt=""><br><img src="http://7xia33.com1.z0.glb.clouddn.com/xiangshanIMG_7060.JPG" alt=""><br><img src="http://7xia33.com1.z0.glb.clouddn.com/xiangshanIMG_7093.JPG" alt=""><br><img src="http://7xia33.com1.z0.glb.clouddn.com/xiangshanIMG_7095.JPG" alt=""><br><img src="http://7xia33.com1.z0.glb.clouddn.com/xiangshanIMG_7152.JPG" alt=""><br><img src="http://7xia33.com1.z0.glb.clouddn.com/xiangshanIMG_7202.JPG" alt=""><br><img src="http://7xia33.com1.z0.glb.clouddn.com/xiangshanIMG_7251.JPG" alt=""><br><img src="http://7xia33.com1.z0.glb.clouddn.com/xiangshanIMG_7257.JPG" alt=""><br><img src="http://7xia33.com1.z0.glb.clouddn.com/xiangshanIMG_7263.JPG" alt=""></p>
<p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7xia33.com1.z0.glb.clouddn.com/IMG_70742324.jpg" alt=""><br>老早爬起来去香山看红叶，没有想象中的那么好，红叶不多，可能去的还不是时候。<br>]]>
    
    </summary>
    
      <category term="摄影" scheme="http://www.haiyue.me/categories/%E6%91%84%E5%BD%B1/"/>
    
  </entry>
  
</feed>