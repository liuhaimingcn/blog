<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[点滴]]></title>
  <subtitle><![CDATA[幽幽一缕香，飘在深深旧梦中，宛如挥手袖底风，淡淡回首，也无风雨也无晴。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.haiyue.me/"/>
  <updated>2015-10-28T11:54:18.000Z</updated>
  <id>http://www.haiyue.me/</id>
  
  <author>
    <name><![CDATA[寻梦的尕柳]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[ES6-Generator函数]]></title>
    <link href="http://www.haiyue.me/2015/10/28/es6-generator/"/>
    <id>http://www.haiyue.me/2015/10/28/es6-generator/</id>
    <published>2015-10-27T16:00:00.000Z</published>
    <updated>2015-10-28T11:54:18.000Z</updated>
    <content type="html"><![CDATA[<p>读阮一峰老师《ECMAScript6入门》一书的笔记</p>
<h2 id="基本概念">基本概念</h2><p>Generator函数是ES6提供的一种异步编程解决方案<br>Generator函数有两个特征。一是，function命令与函数名之间有一个星号；二是，函数体内部使用yield语句，定义不同的内部状态。<br>调用Generator函数后，该函数并不执行，返回的是一个指向内部状态的指针对象（遍历器对象）。下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield语句（或return语句）为止。  </p>
<pre><code><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span><span class="params">()</span></span> {
  yield <span class="string">'hello'</span>;
  yield <span class="string">'world'</span>;
  <span class="keyword">return</span> <span class="string">'ending'</span>;
}
var hw = helloWorldGenerator();
hw.<span class="built_in">next</span>() // { value: <span class="string">'hello'</span>, done: <span class="keyword">false</span> }
hw.<span class="built_in">next</span>() // { value: <span class="string">'world'</span>, done: <span class="keyword">false</span> }
hw.<span class="built_in">next</span>() // { value: <span class="string">'ending'</span>, done: <span class="keyword">true</span> }
hw.<span class="built_in">next</span>() // { value: undefined, done: <span class="keyword">true</span> }
</code></pre><p>每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield语句后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。</p>
<h2 id="yield语句">yield语句</h2><p>遍历器对象的next方法的运行逻辑如下。</p>
<pre><code>遇到<span class="keyword">yield</span>语句，就暂停执行后面的操作，并将紧跟在<span class="keyword">yield</span>后面的那个表达式的值，作为返回的对象的<span class="keyword">value</span>属性值。
下一次调用next方法时，再继续往下执行，直到遇到下一个<span class="keyword">yield</span>语句。
如果没有再遇到新的<span class="keyword">yield</span>语句，就一直运行到函数结束，直到<span class="keyword">return</span>语句为止，并将<span class="keyword">return</span>语句后面的表达式的值，作为返回的对象的<span class="keyword">value</span>属性值。
如果该函数没有<span class="keyword">return</span>语句，则返回的对象的<span class="keyword">value</span>属性值为undefined。
</code></pre><p>yield语句后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为JavaScript提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。<br>一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield语句。<br>yield语句不能用在普通函数中，否则会报错。<br>yield语句如果用在一个表达式之中，必须放在圆括号里面。yield语句用作函数参数或赋值表达式的右边，可以不加括号。</p>
<h2 id="next方法的参数">next方法的参数</h2><p>yield句本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值。<br>由于next方法的参数表示上一个yield语句的返回值，所以第一次使用next方法时，不能带有参数。V8引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。</p>
<h2 id="for…of循环">for…of循环</h2><p>for…of循环可以自动遍历Generator函数，且此时不再需要调用next方法。这里需要注意，一旦next方法的返回对象的done属性为true，for…of循环就会中止，且不包含该返回对象。<br>for…of循环、扩展运算符（…）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，它们可以将Generator函数返回的Iterator对象，作为参数。</p>
<pre><code><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span> <span class="params">()</span> </span>{
  <span class="keyword">yield</span> <span class="number">1</span>
  <span class="keyword">yield</span> <span class="number">2</span>
  <span class="keyword">return</span> <span class="number">3</span>
  <span class="keyword">yield</span> <span class="number">4</span>
}
[...numbers()] <span class="comment">// [1, 2]</span>
<span class="built_in">Array</span>.from(numbers()) <span class="comment">// [1, 2]</span>
<span class="keyword">let</span> [x, y] = numbers();
x <span class="comment">// 1</span>
y <span class="comment">// 2</span>
<span class="keyword">for</span> (<span class="keyword">let</span> n of numbers()) {
  <span class="built_in">console</span>.log(n)
}
<span class="comment">// 1</span>
<span class="comment">// 2</span>
</code></pre><h2 id="Generator-prototype-throw()">Generator.prototype.throw()</h2><p>Generator函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在Generator函数体内捕获。<br>如果Generator函数内部没有部署try…catch代码块，那么throw方法抛出的错误，将被外部try…catch代码块捕获。<br>如果Generator函数内部部署了try…catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历，否则遍历直接终止。<br>Generator函数内抛出的错误，也可以被函数体外的catch捕获。</p>
<h2 id="Generator-prototype-return()">Generator.prototype.return()</h2><p>Generator函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。</p>
<pre><code><span class="function"><span class="keyword">function</span>* <span class="title">gen</span><span class="params">()</span> </span>{
  <span class="keyword">yield</span> <span class="number">1</span>;
  <span class="keyword">yield</span> <span class="number">2</span>;
  <span class="keyword">yield</span> <span class="number">3</span>;
}
<span class="keyword">var</span> g = gen();
g.next()        <span class="comment">// { value: 1, done: false }</span>
g.<span class="keyword">return</span>(<span class="string">"foo"</span>) <span class="comment">// { value: "foo", done: true }</span>
g.next()        <span class="comment">// { value: undefined, done: true }</span>
</code></pre><p>如果return方法调用时，不提供参数，则返回值的vaule属性为undefined。<br>如果Generator函数内部有try…finally代码块，那么return方法会推迟到finally代码块执行完再执行。</p>
<h2 id="yield*语句">yield*语句</h2><p>yield<em>语句，用来在一个Generator函数里面执行另一个Generator函数。<br>yield</em>语句等同于在Generator函数内部，部署一个for…of循环。<br>如果yield*后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。</p>
<pre><code><span class="function"><span class="keyword">function</span>* <span class="title">gen</span><span class="params">()</span></span>{    
  <span class="keyword">yield</span>* [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];
}
gen().next() <span class="comment">// { value:"a", done:false }</span>
</code></pre><h2 id="作为对象属性的Generator函数">作为对象属性的Generator函数</h2><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">obj =</span> &#123;</span><br><span class="line">  * myGeneratorMethod() &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  myGeneratorMethod: <span class="function"><span class="keyword">function</span>* <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="构造函数是Generator函数_//_？">构造函数是Generator函数 // ？</h2><h2 id="Generator函数推导_//_?">Generator函数推导 // ?</h2><h2 id="Generator与状态机_//_?">Generator与状态机 // ?</h2><h2 id="Generator与协程_//_?">Generator与协程 // ?</h2><h2 id="异步操作的同步化表达">异步操作的同步化表达</h2><p>Generator函数的暂停执行的效果，意味着可以把异步操作写在yield语句里面，等到调用next方法时再往后执行。</p>
<pre><code>function* main() {
  <span class="keyword">var</span> <span class="literal">result</span> = <span class="keyword">yield</span> request(<span class="string">"http://some.url"</span>);
  <span class="keyword">var</span> resp = <span class="type">JSON</span>.parse(<span class="literal">result</span>);
    console.log(resp.value);
}
function request(url) {
  makeAjaxCall(url, function(response){
    it.next(response);
  });
}
<span class="keyword">var</span> it = main();
it.next();
</code></pre><h2 id="控制流管理_//_???">控制流管理 // ???</h2><h2 id="部署iterator接口_//_?">部署iterator接口 // ?</h2><h2 id="作为数据结构_//_?">作为数据结构 // ?</h2><p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>读阮一峰老师《ECMAScript6入门》一书的笔记</p>
<h2 id="基本概念">基本概念</h2><p>Generator函数是ES6提供的一种异步编程解决方案<br>Generator函数有两个特征。一是，function命令与函数名之间有一个星号；二是，函数体]]>
    </summary>
    
      <category term="ECMAScript6入门" scheme="http://www.haiyue.me/tags/ECMAScript6%E5%85%A5%E9%97%A8/"/>
    
      <category term="笔记" scheme="http://www.haiyue.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[香山红叶节]]></title>
    <link href="http://www.haiyue.me/2015/10/28/photo/xiangshan/"/>
    <id>http://www.haiyue.me/2015/10/28/photo/xiangshan/</id>
    <published>2015-10-27T16:00:00.000Z</published>
    <updated>2015-10-28T11:28:22.000Z</updated>
    <content type="html"><![CDATA[<p><img src="http://7xia33.com1.z0.glb.clouddn.com/xiangshanIMG_6998.JPG" alt="图片"><br><img src="http://7xia33.com1.z0.glb.clouddn.com/xiangshanIMG_7008.JPG" alt="图片"><br><img src="http://7xia33.com1.z0.glb.clouddn.com/xiangshanIMG_7035.JPG" alt="图片"><br><img src="http://7xia33.com1.z0.glb.clouddn.com/xiangshanIMG_7060.JPG" alt="图片"><br><img src="http://7xia33.com1.z0.glb.clouddn.com/xiangshanIMG_7074.JPG" alt="图片"><br><img src="http://7xia33.com1.z0.glb.clouddn.com/xiangshanIMG_7093.JPG" alt="图片"><br><img src="http://7xia33.com1.z0.glb.clouddn.com/xiangshanIMG_7095.JPG" alt="图片"><br><img src="http://7xia33.com1.z0.glb.clouddn.com/xiangshanIMG_7152.JPG" alt="图片"><br><img src="http://7xia33.com1.z0.glb.clouddn.com/xiangshanIMG_7202.JPG" alt="图片"><br><img src="http://7xia33.com1.z0.glb.clouddn.com/xiangshanIMG_7251.JPG" alt="图片"><br><img src="http://7xia33.com1.z0.glb.clouddn.com/xiangshanIMG_7257.JPG" alt="图片"><br><img src="http://7xia33.com1.z0.glb.clouddn.com/xiangshanIMG_7263.JPG" alt="图片"></p>
<p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="http://7xia33.com1.z0.glb.clouddn.com/xiangshanIMG_6998.JPG" alt="图片"><br><img src="http://7xia33.com1.z0.glb.clouddn.com/xiang]]>
    </summary>
    
      <category term="风景" scheme="http://www.haiyue.me/tags/%E9%A3%8E%E6%99%AF/"/>
    
      <category term="摄影" scheme="http://www.haiyue.me/categories/%E6%91%84%E5%BD%B1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ES6-字符串的扩展]]></title>
    <link href="http://www.haiyue.me/2015/10/26/es6-string/"/>
    <id>http://www.haiyue.me/2015/10/26/es6-string/</id>
    <published>2015-10-25T16:00:00.000Z</published>
    <updated>2015-10-26T15:20:40.000Z</updated>
    <content type="html"><![CDATA[<p>读阮一峰老师《ECMAScript6入门》一书的笔记</p>
<h2 id="字符的Unicode表示法">字符的Unicode表示法</h2><p>   之前不识别在“\u”后面跟上超过0xFFFF的数值（比如\u20BB7），现在用只要将码点放入大括号中就能识别了（比如\u{20BB7}）<br>   所以现在JavaScript共有6种方法可以表示一个字符</p>
<pre><code><span class="string">'\z'</span> === <span class="string">'z'</span>  <span class="comment">// true  </span>
<span class="string">'\172'</span> === <span class="string">'z'</span> <span class="comment">// true  </span>
<span class="string">'\x7A'</span> === <span class="string">'z'</span> <span class="comment">// true  </span>
<span class="string">'\u007A'</span> === <span class="string">'z'</span> <span class="comment">// true  </span>
<span class="string">'\u{7A}'</span> === <span class="string">'z'</span> <span class="comment">// true        </span>
</code></pre><h2 id="codePointAt()_//_?">codePointAt() // ?</h2><p>   JavaScript内部，字符以UTF-16的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode码点大于0xFFFF的字符），JavaScript会认为它们是两个字符。</p>
<pre><code><span class="keyword">var</span> s = <span class="string">"𠮷"</span>;
s.length <span class="comment">// 2</span>
s.charAt(<span class="number">0</span>) <span class="comment">// ''</span>
s.charAt(<span class="number">1</span>) <span class="comment">// ''</span>
s.charCodeAt(<span class="number">0</span>) <span class="comment">// 55362</span>
s.charCodeAt(<span class="number">1</span>) <span class="comment">// 57271</span>
</code></pre><p>   ES6提供了codePointAt方法，能够正确处理4个字节储存的字符，返回一个字符的码点。</p>
<h2 id="String-fromCodePoint()">String.fromCodePoint()</h2><p>   ES5提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别辅助平面的字符（编号大于0xFFFF）。</p>
<pre><code>String.<span class="function"><span class="title">fromCharCode</span><span class="params">(<span class="number">0</span>x20BB7)</span></span> <span class="comment">// "ஷ"</span>
</code></pre><p>   ES6提供了String.fromCodePoint方法，可以识别0xFFFF的字符，弥补了String.fromCharCode方法的不足。</p>
<pre><code>String.<span class="function"><span class="title">fromCodePoint</span><span class="params">(<span class="number">0</span>x20BB7)</span></span> <span class="comment">// "𠮷"</span>
</code></pre><h2 id="字符串的遍历器接口">字符串的遍历器接口</h2><p>   ES6为字符串添加了遍历器接口，使得字符串可以被for…of循环遍历。<br>   除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。</p>
<h2 id="at()_//_ES7">at() // ES7</h2><p>   ES5对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符。<br>   ES7提供了字符串实例的at方法，可以识别Unicode编号大于0xFFFF的字符，返回正确的字符。</p>
<h2 id="normalize()_//_?">normalize() // ?</h2><p>   ES6提供String.prototype.normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。</p>
<h2 id="includes(),_startsWith(),_endsWith()">includes(), startsWith(), endsWith()</h2><p>   传统上，JavaScript只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。  </p>
<pre><code><span class="function"><span class="title">includes</span><span class="params">()</span></span>：返回布尔值，表示是否找到了参数字符串。
<span class="function"><span class="title">startsWith</span><span class="params">()</span></span>：返回布尔值，表示参数字符串是否在源字符串的头部。
<span class="function"><span class="title">endsWith</span><span class="params">()</span></span>：返回布尔值，表示参数字符串是否在源字符串的尾部。
</code></pre><p>   这三个方法都支持第二个参数，endsWith的第二个参数表示它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。</p>
<pre><code>var s = <span class="string">'Hello world!'</span>;
s.<span class="keyword">startsWith</span>(<span class="string">'world'</span>, <span class="number">6</span>) <span class="comment">// true</span>
s.<span class="keyword">endsWith</span>(<span class="string">'Hello'</span>, <span class="number">5</span>) <span class="comment">// true</span>
s.includes(<span class="string">'Hello'</span>, <span class="number">6</span>) <span class="comment">// false</span>
</code></pre><h2 id="repeat()">repeat()</h2><p>   repeat方法返回一个新字符串，表示将原字符串重复n次。</p>
<pre><code><span class="string">'hello'</span>.<span class="function"><span class="title">repeat</span><span class="params">(<span class="number">2</span>)</span></span> <span class="comment">// "hellohello"</span>
<span class="string">'na'</span>.<span class="function"><span class="title">repeat</span><span class="params">(<span class="number">0</span>)</span></span> <span class="comment">// ""</span>
</code></pre><p>   参数如果是小数，会被取整。<br>   如果repeat的参数是负数或者Infinity，会报错。<br>   但是，如果参数是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于-0，repeat视同为0。<br>   参数NaN等同于0。<br>   如果repeat的参数是字符串，则会先转换成数字。</p>
<h2 id="模板字符串">模板字符串</h2><p>   模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。<br>   如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。<br>   如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。<br>   模板字符串中嵌入变量，需要将变量名写在${}之中。<br>   大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。<br>   模板字符串之中还能调用函数。<br>   如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。<br>   如果模板字符串中的变量没有声明，将报错。<br>   由于模板字符串的大括号内部，就是执行JavaScript代码，因此如果大括号内部是一个字符串，将会原样输出。</p>
<h2 id="标签模板">标签模板</h2><p>   模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。<br>   tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，其他参数，都是模板字符串各个变量被替换后的值。</p>
<pre><code><span class="reserved">var</span> a = <span class="number">5</span>;
<span class="reserved">var</span> b = <span class="number">10</span>;
<span class="reserved">function</span> tag(s, v1, v2) {
  <span class="built_in">console</span>.log(s[<span class="number">0</span>]); <span class="regexp">//</span> <span class="string">"Hello "</span>
  <span class="built_in">console</span>.log(s[<span class="number">1</span>]); <span class="regexp">//</span> <span class="string">" world "</span>
  <span class="built_in">console</span>.log(s[<span class="number">2</span>]); <span class="regexp">//</span> <span class="string">""</span>
  <span class="built_in">console</span>.log(v1); <span class="regexp">//</span> <span class="number">15</span>
  <span class="built_in">console</span>.log(v2); <span class="regexp">//</span> <span class="number">50</span>
  <span class="keyword">return</span> <span class="string">"OK"</span>;
}
tag`<span class="javascript">Hello ${ a + b } world ${ a * b}</span>`; <span class="regexp">//</span> <span class="string">"OK"</span>  等同于 tag([<span class="string">'Hello '</span>, <span class="string">' world '</span>, <span class="string">''</span>], <span class="number">15</span>, <span class="number">50</span>)
</code></pre><p>   “标签模板”的一个重要应用，就是过滤HTML字符串，防止用户输入恶意内容。</p>
<pre><code><span class="keyword">var</span> message = SaferHTML`&lt;p&gt;${sender} has sent you a message.&lt;/p&gt;`;
<span class="function"><span class="keyword">function</span> <span class="title">SaferHTML</span><span class="params">(templateData)</span> </span>{
  <span class="keyword">var</span> s = templateData[<span class="number">0</span>];
  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; arguments.length; i++) {
    <span class="keyword">var</span> arg = String(arguments[i]);
    <span class="comment">// Escape special characters in the substitution.</span>
    s += arg.replace(/&amp;/g, <span class="string">"&amp;amp;"</span>).replace(/&lt;/g, <span class="string">"&amp;lt;"</span>).replace(/&gt;/g, <span class="string">"&amp;gt;"</span>);
    <span class="comment">// Don't escape special characters in the template.</span>
    s += templateData[i];
  }
  <span class="keyword">return</span> s;
}
</code></pre><p>   模板处理函数的第一个参数（模板字符串数组），还有一个raw属性。该数组的成员与strings数组完全一致。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw数组会将\n视为\和n两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。</p>
<h2 id="String-raw()">String.raw()</h2><p>   String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。</p>
<pre><code>String.raw<span class="escape">`H</span>i\n${<span class="number">2</span>+<span class="number">3</span>}!<span class="escape">`;</span> // <span class="string">"Hi\\n5!"</span>
</code></pre><p>   String.raw方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组。</p>
<pre><code><span class="filename">String.raw({ raw</span>: <span class="string">'test'</span> }, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>); // <span class="string">'t0e1s2t'</span>, 等同于 <span class="filename">String.raw({ raw</span>: [<span class="string">'t'</span>,<span class="string">'e'</span>,<span class="string">'s'</span>,<span class="string">'t'</span>] }, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);
</code></pre><p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>读阮一峰老师《ECMAScript6入门》一书的笔记</p>
<h2 id="字符的Unicode表示法">字符的Unicode表示法</h2><p>   之前不识别在“\u”后面跟上超过0xFFFF的数值（比如\u20BB7），现在用只要将码点放入大括号中就能识别了（比如]]>
    </summary>
    
      <category term="ECMAScript6入门" scheme="http://www.haiyue.me/tags/ECMAScript6%E5%85%A5%E9%97%A8/"/>
    
      <category term="笔记" scheme="http://www.haiyue.me/categories/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iTerm2的使用]]></title>
    <link href="http://www.haiyue.me/2015/07/23/iterm2/"/>
    <id>http://www.haiyue.me/2015/07/23/iterm2/</id>
    <published>2015-07-22T16:00:00.000Z</published>
    <updated>2015-08-05T05:14:08.000Z</updated>
    <content type="html"><![CDATA[<p>自从换了mac后连接远程linux服务器一直用电脑自带的终端，每次都要输密码，烦死了。看同事用iTerm挺方便的，就自己也弄了一个。</p>
<h2 id="下载地址">下载地址</h2><p><a href="http://www.iterm2.com/" target="_blank" rel="external">http://www.iterm2.com/</a></p>
<h3 id="记住远程服务器密码">记住远程服务器密码</h3><p>打开设置<br><img src="/img/iterm/iterm1.jpg" alt="图片"><br>相关配置<br><img src="/img/iterm/iterm2.jpg" alt="图片"><br>脚本<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">timeout</span> <span class="number">30</span></span><br><span class="line">spawn ssh liuhaiming@<span class="number">122.92</span><span class="number">.222</span><span class="number">.122</span> -p51618</span><br><span class="line">expect <span class="string">"*password*"</span></span><br><span class="line">send “**********\n<span class="string">"</span><br><span class="line">interact</span></span><br></pre></td></tr></table></figure></p>
<h2 id="替换图标">替换图标</h2><p>原图标看着不好看,替换一个喜欢的图标<br><img src="/img/iterm/iterm3.jpg" alt="图片">  <img src="/img/iterm/iterm4.jpg" alt="图片"><br>找好自己要替换的图标<br><a href="https://dribbble.com/shots/656627-Terminal-Macintosh-Icon" target="_blank" rel="external">https://dribbble.com/shots/656627-Terminal-Macintosh-Icon</a><br>找到自己要替换图标的app<br><img src="/img/iterm/iterm5.jpg" alt="图片"><br>右键显示简介，复制下载好的图标，并选中要替换的图标 command + v 就替换好了<br><img src="/img/iterm/iterm6.jpg" alt="图片">    </p>
<h2 id="换个自己喜欢的主题">换个自己喜欢的主题</h2><p><a href="http://iterm2colorschemes.com/" target="_blank" rel="external">http://iterm2colorschemes.com/</a></p>
<h2 id="相关命令">相关命令</h2><p>command + O: 打开配置方便选择<br><img src="/img/iterm/iterm7.jpg" alt="图片">    </p>
<p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>自从换了mac后连接远程linux服务器一直用电脑自带的终端，每次都要输密码，烦死了。看同事用iTerm挺方便的，就自己也弄了一个。</p>
<h2 id="下载地址">下载地址</h2><p><a href="http://www.iterm2.com/" target=]]>
    </summary>
    
      <category term="软件" scheme="http://www.haiyue.me/tags/%E8%BD%AF%E4%BB%B6/"/>
    
      <category term="软件" scheme="http://www.haiyue.me/categories/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[setImmediate,setTimeout,nextTick的区别是什么]]></title>
    <link href="http://www.haiyue.me/2015/07/22/nexttick_immediate/"/>
    <id>http://www.haiyue.me/2015/07/22/nexttick_immediate/</id>
    <published>2015-07-21T16:00:00.000Z</published>
    <updated>2015-07-21T18:01:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id="区别">区别</h2><p>1、nextTick和setImmediate主要的区别在于任务插入的位置nextTick的插入位置是在当前帧的末尾、io回调之前，如果nextTick过多，会导致io回调不断延后setImmediate的插入位置是在下一帧，不会影响io回调。</p>
<p>2、Nodejs的特点是事件驱动，异步I/O产生的高并发，产生此特点的引擎是事件循环，事件被分门别类地归到对应的事件观察者上，比如idle观察者，定时器观察者，I/O观察者等等，事件循环每次循环称为Tick，每次Tick按照先后顺序从事件观察者中取出事件进行处理。<br>调用setTimeout()时创建的计时器会被放入定时器观察者内部的红黑树中，每次Tick时，会从该红黑树中检查定时器是否超过定时时间，超过的话，就立即执行对应的回调函数。由于定时器是超时触发，这会导致触发精确度降低。</p>
<h2 id="代码例子">代码例子</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nextTick</span><span class="params">(msg, cb)</span> </span>&#123;</span><br><span class="line">  process.nextTick(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'tick: '</span> + msg);</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      cb();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">immediate</span><span class="params">(msg, cb)</span> </span>&#123;</span><br><span class="line">  setImmediate(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate : '</span> + msg);</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      cb();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nextTick(<span class="string">'1'</span>);</span><br><span class="line">nextTick(<span class="string">'2'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  nextTick(<span class="string">'10'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">immediate(<span class="string">'3'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  nextTick(<span class="string">'5'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">nextTick(<span class="string">'7'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  immediate(<span class="string">'9'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">immediate(<span class="string">'4'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  nextTick(<span class="string">'8'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> timer = setInterval(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  n++;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'interval:'</span>, n);</span><br><span class="line">  nextTick(<span class="string">'tick from interval: '</span> +  n);</span><br><span class="line">  nextTick(<span class="string">'another tick from interval: '</span> +  n);</span><br><span class="line">  immediate(<span class="string">'immediate from interval: '</span> + n);</span><br><span class="line">  immediate(<span class="string">'another immediate from interval: '</span> + n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( n === <span class="number">3</span> ) &#123;</span><br><span class="line">    clearInterval(timer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'the last line of the program.'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="结果">结果</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">the last line of the program.</span><br><span class="line"><span class="string">tick:</span> <span class="number">1</span></span><br><span class="line"><span class="string">tick:</span> <span class="number">2</span></span><br><span class="line"><span class="string">tick:</span> <span class="number">7</span></span><br><span class="line"><span class="string">tick:</span> <span class="number">10</span></span><br><span class="line"><span class="string">interval:</span> <span class="number">1</span></span><br><span class="line"><span class="string">tick:</span> tick from <span class="string">interval:</span> <span class="number">1</span></span><br><span class="line"><span class="string">tick:</span> another tick from <span class="string">interval:</span> <span class="number">1</span></span><br><span class="line"><span class="string">immediate :</span> <span class="number">3</span></span><br><span class="line"><span class="string">immediate :</span> <span class="number">4</span></span><br><span class="line"><span class="string">immediate :</span> <span class="number">9</span></span><br><span class="line"><span class="string">immediate :</span> immediate from <span class="string">interval:</span> <span class="number">1</span></span><br><span class="line"><span class="string">immediate :</span> another immediate from <span class="string">interval:</span> <span class="number">1</span></span><br><span class="line"><span class="string">tick:</span> <span class="number">5</span></span><br><span class="line"><span class="string">tick:</span> <span class="number">8</span></span><br><span class="line"><span class="string">interval:</span> <span class="number">2</span></span><br><span class="line"><span class="string">tick:</span> tick from <span class="string">interval:</span> <span class="number">2</span></span><br><span class="line"><span class="string">tick:</span> another tick from <span class="string">interval:</span> <span class="number">2</span></span><br><span class="line"><span class="string">immediate :</span> immediate from <span class="string">interval:</span> <span class="number">2</span></span><br><span class="line"><span class="string">immediate :</span> another immediate from <span class="string">interval:</span> <span class="number">2</span></span><br><span class="line"><span class="string">interval:</span> <span class="number">3</span></span><br><span class="line"><span class="string">tick:</span> tick from <span class="string">interval:</span> <span class="number">3</span></span><br><span class="line"><span class="string">tick:</span> another tick from <span class="string">interval:</span> <span class="number">3</span></span><br><span class="line"><span class="string">immediate :</span> immediate from <span class="string">interval:</span> <span class="number">3</span></span><br><span class="line"><span class="string">immediate :</span> another immediate from <span class="string">interval:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="Maximum_call_stack_size_exceeded错误的原因">Maximum call stack size exceeded错误的原因</h2><p>之所以会发生Maximum call stack size exceeded,因为process.maxTickDepth的缺省值是1000，如果递归调用nextTick只能调用1000次，超过1000就会报这个错，但并不是真正栈溢出，只是想给你一个提示不希望你递归调用nextTick太多次，如果nextTick递归调用，那么其他的回调事件就会等待，会造成event loop饥饿，所以官方推荐用setImmediate作为递归调用</p>
<h2 id="资料来源">资料来源</h2><p><a href="https://cnodejs.org/topic/519b523c63e9f8a5429b25e3" target="_blank" rel="external">求科普setImmediate API</a><br><a href="http://www.cnblogs.com/kongxianghai/p/3942226.html" target="_blank" rel="external">setTimeout，setInterval，process.nextTick，setImmediate in Nodejs</a></p>
<p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="区别">区别</h2><p>1、nextTick和setImmediate主要的区别在于任务插入的位置nextTick的插入位置是在当前帧的末尾、io回调之前，如果nextTick过多，会导致io回调不断延后setImmediate的插入位置是在下一帧，不会影响i]]>
    </summary>
    
      <category term="js" scheme="http://www.haiyue.me/tags/js/"/>
    
      <category term="node" scheme="http://www.haiyue.me/tags/node/"/>
    
      <category term="node" scheme="http://www.haiyue.me/categories/node/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[项目总结]]></title>
    <link href="http://www.haiyue.me/2015/03/26/summary/"/>
    <id>http://www.haiyue.me/2015/03/26/summary/</id>
    <published>2015-03-25T16:00:00.000Z</published>
    <updated>2015-07-21T18:00:00.000Z</updated>
    <content type="html"><![CDATA[<p>来现在这个公司已经大半年了，做了许多工作，也学习到许多新的知识，一直处在忙忙碌碌工作中，前端后端都做了一些，要学习的东西感觉太多。最近几天工作相对轻松些，准备花点时间整理一下自己的知识，在这篇文章中先大概整理一下工作中所用到的知识及技术，然后再抽空进行细化的整理，希望通过这次反省找到自己得薄弱和不足，并进行针对性的补充和学习。</p>
<p>整体项目结构是进行前后端分离的，这样既能让前后端人员各司其职提高工作效率，也能使后端同时给多个前端提供数据支持（微信，WEB，APP共用一个后端）</p>
<h2 id="后端">后端</h2><h3 id="项目：ycombo">项目：ycombo</h3><pre><code>作用：通过RESTFUL的方式对外提供接口
使用技术：JAVA、Spring、SpringMvc、Mybatis、Maven、Nginx
工具：IntelliJ IDEA、<span class="keyword">Mac</span>终端、Sequel <span class="keyword">Pro</span>、FileZilla
第三方接口：支付宝支付、微信支付、SendCloud、极光推送、亿美短信、七牛
</code></pre><h2 id="前端">前端</h2><h3 id="项目名：node-wechat">项目名：node-wechat</h3><pre><code>作用：微信公众账号系统
使用技术：CSS、JS、NodeJS、Express、jade、<span class="keyword">forever</span>、SuperAgent、Mongodb
工具：Sublime、Robomongo、PS
第三方接口：GA、微信接口、七牛
</code></pre><h3 id="项目名：node-admin">项目名：node-admin</h3><pre><code>作用：后台管理系统
使用技术：CSS、JS、NodeJS、Express、jade、<span class="keyword">forever</span>、SuperAgent、Mongodb、Jquery、bootstrap
工具：Sublime、Robomongo
第三方接口：七牛
</code></pre><h3 id="项目名：node-web">项目名：node-web</h3><pre><code>作用：web网站的实现
使用技术：CSS、JS、NodeJS、Express、jade、<span class="keyword">forever</span>、SuperAgent
工具：Sublime
第三方接口：七牛
</code></pre><h3 id="项目名：node-app">项目名：node-app</h3><pre><code>作用：因为后台接口服务器对访问端口进行限制，此项目用来作为app和后台接口的数据中转
使用技术：NodeJS、Express、<span class="keyword">forever</span>、SuperAgent
工具：Sublime
</code></pre><h3 id="项目名：app">项目名：app</h3><pre><code>作用：iOSAPP
使用技术：未知
</code></pre><p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>来现在这个公司已经大半年了，做了许多工作，也学习到许多新的知识，一直处在忙忙碌碌工作中，前端后端都做了一些，要学习的东西感觉太多。最近几天工作相对轻松些，准备花点时间整理一下自己的知识，在这篇文章中先大概整理一下工作中所用到的知识及技术，然后再抽空进行细化的整理，希望通过这]]>
    </summary>
    
      <category term="总结" scheme="http://www.haiyue.me/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="总结" scheme="http://www.haiyue.me/categories/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[常用网站记录]]></title>
    <link href="http://www.haiyue.me/2015/03/10/web-sit/"/>
    <id>http://www.haiyue.me/2015/03/10/web-sit/</id>
    <published>2015-03-09T16:00:00.000Z</published>
    <updated>2015-07-21T17:54:57.000Z</updated>
    <content type="html"><![CDATA[<p>记录自己收集的一些网站资源，便于查阅</p>
<h2 id="博客">博客</h2><h3 id="寻梦的尕柳"><a href="http://www.liuhaiming.me" target="_blank" rel="external">寻梦的尕柳</a></h3><p>地址：<a href="http://www.liuhaiming.me" target="_blank" rel="external">http://www.liuhaiming.me</a><br>备注：我自己得个人博客，记录学习以及生活</p>
<hr>
<h3 id="粉丝日志"><a href="http://blog.fens.me" target="_blank" rel="external">粉丝日志</a></h3><p>地址：<a href="http://blog.fens.me" target="_blank" rel="external">http://blog.fens.me</a><br>备注：跨界的IT博客|Hadoop家族, R, RHadoop, Nodejs, AngularJS, KVM, NoSQL, IT金融</p>
<hr>
<h3 id="当然我在扯淡"><a href="http://www.yinwang.org" target="_blank" rel="external">当然我在扯淡</a></h3><p>地址：<a href="http://www.yinwang.org" target="_blank" rel="external">http://www.yinwang.org</a><br>备注：王垠的博客                </p>
<hr>
<p><br></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>记录自己收集的一些网站资源，便于查阅</p>
<h2 id="博客">博客</h2><h3 id="寻梦的尕柳"><a href="http://www.liuhaiming.me" target="_blank" rel="external">寻梦的尕柳</a></h3>]]>
    </summary>
    
      <category term="资源" scheme="http://www.haiyue.me/tags/%E8%B5%84%E6%BA%90/"/>
    
      <category term="资源" scheme="http://www.haiyue.me/categories/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
</feed>