<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ES6-Generator函数 - 寻梦的尕柳</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="基本概念Generator函数是ES6提供的一种异步编程解决方案Generator函数有两个特征。一是，function命令与函数名之间有一个星号；二是，函数体内部使用yield语句，定义不同的内部状态。调用Generator函数后，该函数并不执行，返回的是一个指向内部状态的指针对象（遍历器对象）。下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6-Generator函数">
<meta property="og:url" content="http://www.haiyue.me/2015/10/28/es6-generator/index.html">
<meta property="og:site_name" content="寻梦的尕柳">
<meta property="og:description" content="基本概念Generator函数是ES6提供的一种异步编程解决方案Generator函数有两个特征。一是，function命令与函数名之间有一个星号；二是，函数体内部使用yield语句，定义不同的内部状态。调用Generator函数后，该函数并不执行，返回的是一个指向内部状态的指针对象（遍历器对象）。下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES6-Generator函数">
<meta name="twitter:description" content="基本概念Generator函数是ES6提供的一种异步编程解决方案Generator函数有两个特征。一是，function命令与函数名之间有一个星号；二是，函数体内部使用yield语句，定义不同的内部状态。调用Generator函数后，该函数并不执行，返回的是一个指向内部状态的指针对象（遍历器对象）。下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="/webfonts/ptserif/main.css" rel='stylesheet' type='text/css'>
  <link href="/webfonts/source-code-pro/main.css" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>

<body>
  <div id="container">
    <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-inner" class="inner">
      <a id="main-nav-toggle" class="nav-icon" href="javascript:;"></a>
      <a id="logo" class="logo logo-text" href="/">寻梦的尕柳</a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/categories/编程">编程</a>
        
          <a class="main-nav-link" href="/categories/笔记">笔记</a>
        
          <a class="main-nav-link" href="/categories/摄影">摄影</a>
        
          <a class="main-nav-link" href="/tags">标签</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于我</a>
        
      </nav>
      <nav id="sub-nav">
        <div id="search-form-wrap">
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="q" value="site:http://www.haiyue.me"></form>
        </div>
      </nav>
    </div>
  </div>
</header>
    <section id="main" class="outer"><article id="post-es6-generator" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      ES6-Generator函数
    </h1>
  

      </header>
    
    <div class="article-meta">
      <a href="/2015/10/28/es6-generator/" class="article-date">
  <time datetime="2015-10-27T16:00:00.000Z" itemprop="datePublished">2015-10-28</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/笔记/">笔记</a>
  </div>

      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="基本概念">基本概念</h2><p>Generator函数是ES6提供的一种异步编程解决方案<br>Generator函数有两个特征。一是，function命令与函数名之间有一个星号；二是，函数体内部使用yield语句，定义不同的内部状态。<br>调用Generator函数后，该函数并不执行，返回的是一个指向内部状态的指针对象（遍历器对象）。下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield语句（或return语句）为止。  </p>
<pre><code><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span><span class="params">()</span></span> {
  yield <span class="string">'hello'</span>;
  yield <span class="string">'world'</span>;
  <span class="keyword">return</span> <span class="string">'ending'</span>;
}
var hw = helloWorldGenerator();
hw.<span class="built_in">next</span>() // { value: <span class="string">'hello'</span>, done: <span class="keyword">false</span> }
hw.<span class="built_in">next</span>() // { value: <span class="string">'world'</span>, done: <span class="keyword">false</span> }
hw.<span class="built_in">next</span>() // { value: <span class="string">'ending'</span>, done: <span class="keyword">true</span> }
hw.<span class="built_in">next</span>() // { value: undefined, done: <span class="keyword">true</span> }
</code></pre><p>每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield语句后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。</p>
<a id="more"></a> 
<h2 id="yield语句">yield语句</h2><p>遍历器对象的next方法的运行逻辑如下。</p>
<pre><code>遇到<span class="keyword">yield</span>语句，就暂停执行后面的操作，并将紧跟在<span class="keyword">yield</span>后面的那个表达式的值，作为返回的对象的<span class="keyword">value</span>属性值。
下一次调用next方法时，再继续往下执行，直到遇到下一个<span class="keyword">yield</span>语句。
如果没有再遇到新的<span class="keyword">yield</span>语句，就一直运行到函数结束，直到<span class="keyword">return</span>语句为止，并将<span class="keyword">return</span>语句后面的表达式的值，作为返回的对象的<span class="keyword">value</span>属性值。
如果该函数没有<span class="keyword">return</span>语句，则返回的对象的<span class="keyword">value</span>属性值为undefined。
</code></pre><p>yield语句后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为JavaScript提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。<br>一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield语句。<br>yield语句不能用在普通函数中，否则会报错。<br>yield语句如果用在一个表达式之中，必须放在圆括号里面。yield语句用作函数参数或赋值表达式的右边，可以不加括号。</p>
<h2 id="next方法的参数">next方法的参数</h2><p>yield句本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值。<br>由于next方法的参数表示上一个yield语句的返回值，所以第一次使用next方法时，不能带有参数。V8引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。</p>
<h2 id="for…of循环">for…of循环</h2><p>for…of循环可以自动遍历Generator函数，且此时不再需要调用next方法。这里需要注意，一旦next方法的返回对象的done属性为true，for…of循环就会中止，且不包含该返回对象。<br>for…of循环、扩展运算符（…）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，它们可以将Generator函数返回的Iterator对象，作为参数。</p>
<pre><code><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span> <span class="params">()</span> </span>{
  <span class="keyword">yield</span> <span class="number">1</span>
  <span class="keyword">yield</span> <span class="number">2</span>
  <span class="keyword">return</span> <span class="number">3</span>
  <span class="keyword">yield</span> <span class="number">4</span>
}
[...numbers()] <span class="comment">// [1, 2]</span>
<span class="built_in">Array</span>.from(numbers()) <span class="comment">// [1, 2]</span>
<span class="keyword">let</span> [x, y] = numbers();
x <span class="comment">// 1</span>
y <span class="comment">// 2</span>
<span class="keyword">for</span> (<span class="keyword">let</span> n of numbers()) {
  <span class="built_in">console</span>.log(n)
}
<span class="comment">// 1</span>
<span class="comment">// 2</span>
</code></pre><h2 id="Generator-prototype-throw()">Generator.prototype.throw()</h2><p>Generator函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在Generator函数体内捕获。<br>如果Generator函数内部没有部署try…catch代码块，那么throw方法抛出的错误，将被外部try…catch代码块捕获。<br>如果Generator函数内部部署了try…catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历，否则遍历直接终止。<br>Generator函数内抛出的错误，也可以被函数体外的catch捕获。</p>
<h2 id="Generator-prototype-return()">Generator.prototype.return()</h2><p>Generator函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。</p>
<pre><code><span class="function"><span class="keyword">function</span>* <span class="title">gen</span><span class="params">()</span> </span>{
  <span class="keyword">yield</span> <span class="number">1</span>;
  <span class="keyword">yield</span> <span class="number">2</span>;
  <span class="keyword">yield</span> <span class="number">3</span>;
}
<span class="keyword">var</span> g = gen();
g.next()        <span class="comment">// { value: 1, done: false }</span>
g.<span class="keyword">return</span>(<span class="string">"foo"</span>) <span class="comment">// { value: "foo", done: true }</span>
g.next()        <span class="comment">// { value: undefined, done: true }</span>
</code></pre><p>如果return方法调用时，不提供参数，则返回值的vaule属性为undefined。<br>如果Generator函数内部有try…finally代码块，那么return方法会推迟到finally代码块执行完再执行。</p>
<h2 id="yield*语句">yield*语句</h2><p>yield<em>语句，用来在一个Generator函数里面执行另一个Generator函数。<br>yield</em>语句等同于在Generator函数内部，部署一个for…of循环。<br>如果yield*后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。</p>
<pre><code><span class="function"><span class="keyword">function</span>* <span class="title">gen</span><span class="params">()</span></span>{    
  <span class="keyword">yield</span>* [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];
}
gen().next() <span class="comment">// { value:"a", done:false }</span>
</code></pre><h2 id="作为对象属性的Generator函数">作为对象属性的Generator函数</h2><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">obj =</span> &#123;</span><br><span class="line">  * myGeneratorMethod() &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  myGeneratorMethod: <span class="function"><span class="keyword">function</span>* <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="构造函数是Generator函数_//_？">构造函数是Generator函数 // ？</h2><h2 id="Generator函数推导_//_?">Generator函数推导 // ?</h2><h2 id="Generator与状态机_//_?">Generator与状态机 // ?</h2><h2 id="Generator与协程_//_?">Generator与协程 // ?</h2><h2 id="异步操作的同步化表达">异步操作的同步化表达</h2><p>Generator函数的暂停执行的效果，意味着可以把异步操作写在yield语句里面，等到调用next方法时再往后执行。</p>
<pre><code>function* main() {
  <span class="keyword">var</span> <span class="literal">result</span> = <span class="keyword">yield</span> request(<span class="string">"http://some.url"</span>);
  <span class="keyword">var</span> resp = <span class="type">JSON</span>.parse(<span class="literal">result</span>);
    console.log(resp.value);
}
function request(url) {
  makeAjaxCall(url, function(response){
    it.next(response);
  });
}
<span class="keyword">var</span> it = main();
it.next();
</code></pre><h2 id="控制流管理_//_???">控制流管理 // ???</h2><h2 id="部署iterator接口_//_?">部署iterator接口 // ?</h2><h2 id="作为数据结构_//_?">作为数据结构 // ?</h2><p>读阮一峰老师《ECMAScript6入门》一书的笔记<br><br></p>

      
    </div>
    
    
      <footer class="article-footer">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ECMAScript6入门/">ECMAScript6入门</a></li></ul>

      </footer>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/10/28/photo/xiangshan/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-title"><span>&lt;</span>&nbsp;
        
          香山红叶节
        
      </div>
    </a>
  
  
    <a href="/2015/10/26/es6-string/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">ES6-字符串的扩展&nbsp;<span>&gt;</span></div>
    </a>
  
</nav>

  
</article>


  <section id="comments">
    <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="post-es6-generator" data-title="ES6-Generator函数" data-url="http://www.haiyue.me/2015/10/28/es6-generator/"></div>
    <!-- 多说评论框 end -->
    <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'liuhaiming'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  </section>
  </section>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 寻梦的尕柳&nbsp;
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    

<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>
  </div>
</body>
</html>